const fs = require('fs');
const flatten = require('lodash.flatten');
const axios = require('axios');
const crypto = require('crypto');
const { validateFileByUrl } = require('@mfe/stark-validator');
const promiseLimit = require('promise-limit');

const VALIDATE_CONCURRENT_COUNT = 5;

// shuffle files by size
function shuffleFiles(files) {
  const sortedFiles = files.sort((fileA, fileB) => fileA.fileSize - fileB.fileSize);
  const times = files.length >> 1;
  for (let index = 0; index < times; index += 2) {
    const revertIndex = sortedFiles.length - index - 1;
    const elementA = sortedFiles[index];
    const elementB = sortedFiles[revertIndex];
    sortedFiles[index] = elementB;
    sortedFiles[revertIndex] = elementA;
  }
  return sortedFiles;
}

function appendFileSize(files) {
  for (let index = 0; index < files.length; index++) {
    const file = files[index];
    if (!file.fileSize && file.fileSize !== 0) {
      file.fileSize = fs.statSync(file.filePath).size;
    }
  }
  return files;
}

function mergeStaticUploadResults(uploadResultArray) {
  const cdnPathArray = uploadResultArray.map(uploadResult => uploadResult.cdnpath);
  const mergedCode = uploadResultArray.reduce(
    (previous, uploadResult) => (uploadResult.code === 200 ? previous : uploadResult.code),
    200
  );
  return {
    code: mergedCode,
    cdnpath: flatten(cdnPathArray)
  };
}

function findFileCdnUrl(fileName, uploadResult) {
  for (let i = 0; i < uploadResult.cdnpath.length; i++) {
    if (uploadResult.cdnpath[i].relative === fileName && uploadResult.cdnpath[i].cdn) {
      // cdn is protocol free
      return `https:${uploadResult.cdnpath[i].cdn}`;
    }
  }
  throw new Error(`Uploaded file ${fileName} cannot be found on CDN.`);
}

async function validateMassiveStaticFile(files, uploadResult) {
  const failedFiles = [];
  const missingFiles = [];
  const uploadResultObj = uploadResultCdnpathArrayToObj(uploadResult);
  const limit = promiseLimit(VALIDATE_CONCURRENT_COUNT);
  const validatingPromiseArray = files.map(file => {
    const { fileName, filePath, checksum } = file;
    if (uploadResultObj.hasOwnProperty(fileName)) {
      const cdnPath = uploadResultObj[fileName];
      return limit(async () => {
        if (checksum) {
          const { data: remoteContent } = await axios.get(cdnPath);
          const checkResult = validateCheckSum(checksum, remoteContent);
          if (checkResult) {
            console.log(`Uploaded file ${fileName} success!`);
          } else {
            console.log(`Uploaded file ${fileName} failed!`);
            failedFiles.push(file);
          }
        } else {
          const validateResult = await validateFileByUrl(cdnPath, filePath);
          if (validateResult) {
            console.log(`Uploaded file ${fileName} success!`);
          } else {
            console.log(`Uploaded file ${fileName} failed!`);
            failedFiles.push(file);
          }
        }
      });
    }
    missingFiles.push(file);
  });

  return Promise.all(validatingPromiseArray).then(() => ({
    failedFiles: [...missingFiles, ...failedFiles],
    allFilesUploadSuccess: !(missingFiles.length && failedFiles.length)
  }));
}

function uploadResultCdnpathArrayToObj(uploadResult) {
  const uploadResultObj = {};
  if (Array.isArray(uploadResult.cdnpath)) {
    uploadResult.cdnpath.forEach(({ relative, cdn }) => {
      uploadResultObj[relative] = `https:${cdn}`;
    });
  }
  return uploadResultObj;
}

function validateCheckSum(checksum, fileContent) {
  const md5 = crypto.createHash('md5');
  const checksumRemoteFile = md5.update(fileContent).digest('hex');
  return checksum.toLowerCase() === checksumRemoteFile.toLowerCase();
}
function batchFilesByCount(files, countLimit) {
  const filesCount = files.length;
  const result = [];
  if (filesCount > countLimit) {
    const batchCount = Math.ceil(filesCount / countLimit);
    for (let i = 0; i < batchCount; i++) {
      result.push(files.splice(0, countLimit));
    }
    return result;
  }
  return [files];
}
module.exports = {
  shuffleFiles,
  appendFileSize,
  mergeStaticUploadResults,
  findFileCdnUrl,
  validateMassiveStaticFile,
  uploadResultCdnpathArrayToObj,
  validateCheckSum,
  batchFilesByCount
};