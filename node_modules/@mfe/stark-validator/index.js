const fs = require('fs');
const { URL } = require('whatwg-url');
const axios = require('axios');
const { recoverMin } = require('./patch');
const crc32Str = require('./crc32');

const DEFAULT_FALLBACK_CDN = 'https://s3plus.meituan.net/v1/mss_e2821d7f0cfe4ac1bf9202ecf9590e67/cdn-prod';

const STARK_DIFF_STATUS = {
  PATCH: 2,
  FULL: 1,
  FAILED: 0
};

// CDN厂商会在频繁访问后判定为爬虫行为，屏蔽请求
// http://ones.sankuai.com/ones/product/1606/defectdetail/814723
axios.defaults.headers.get['User-Agent'] = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36 ${generateRandomVersion()}`;

function generateRandomVersion() {
  const random = (Math.random() * 100).toString().slice(0, 6);
  const ua = `StarkUploader/${random}`;
  return ua;
}

function validateChecksum(content, targetChecksum) {
  const computedChecksum = crc32Str(content);
  return {
    computedChecksum: computedChecksum,
    targetChecksum: targetChecksum,
    matched: computedChecksum === targetChecksum
  };
}

function validatePatch(sourceString, targetString, patchString, targetChecksum) {
  try {
    const { content } = recoverMin(sourceString, patchString);
    if(content !== targetString) {
      return false;
    }
    if (!Number.isInteger(targetChecksum)) {
      console.log('File checksum is NOT provided, skip.');
      return true;
    }
    console.log('Validating checksum...');
    const checksumInfo = validateChecksum(content, targetChecksum);
    const computedChecksum = checksumInfo.computedChecksum;
    console.log('Computed checksum', computedChecksum);
    console.log('Provided checksum', targetChecksum);
    return checksumInfo.matched;
  } catch (error) {
    console.error(error);
    return false;
  }
  return false;
}

function validateFullFile(oneFile, anotherFile) {
  return oneFile === anotherFile;
}

function parseProjectNameFromUrl(url) {
  const projectName = url.pathname.split('/').slice(-1)[0];
  return projectName;  
}

function parseFilePairFromUrl(url) {
  return {
    oldFilePath: url.searchParams.get('oldFilePath'),
    newFilePath: url.searchParams.get('newFilePath'),
  };
}

function constructStaticFileUrl(filePair, projectName, fallbackCDN) {
  return {
    oldFileUrl: `${fallbackCDN}/file:${projectName}/${decodeURI(filePair.oldFilePath)}`,
    newFileUrl: `${fallbackCDN}/file:${projectName}/${decodeURI(filePair.newFilePath)}`,
  };
}

function parsePatchUrl(patchUrl) {
  const url = new URL(patchUrl);
  const projectName = parseProjectNameFromUrl(url);
  const filePair = parseFilePairFromUrl(url);
  return {
    projectName,
    filePair,
  };
}

function validatePatchByUrl(patchUrl, options = {
  fallbackCDN: DEFAULT_FALLBACK_CDN,
}) {
  const { fallbackCDN } = options;
  const { projectName, filePair } = parsePatchUrl(patchUrl);
  const staticUrlPair = constructStaticFileUrl(filePair, projectName, fallbackCDN);
  
  let oldFileResponse  = '';
  
  return axios.get(staticUrlPair.oldFileUrl)
  .catch()
  .then(response => {
    oldFileResponse = response;
  }, (err) => {
    // old file may not present on Stark S3 CDN.
    if (String(err).indexOf('404')) {
      console.log('Old file is not found, check new file only...');
    } else {
      console.error(err);
      throw err;
    }
  })
  .then(() => {
    return Promise.all([
      axios.get(staticUrlPair.newFileUrl),
      axios.get(patchUrl),
    ]);
  })
  .then((responses) => {
    const [newFileResponse, patchResponse] = responses;
    
    const oldFileString = oldFileResponse.data;
    const newFileString = newFileResponse.data;
    
    const status = patchResponse.data.status;
    
    if (!Number.isInteger(status)) {
      return false;
    }
    
    if (status === STARK_DIFF_STATUS.FAILED) {
      return false;
    } else if (status === STARK_DIFF_STATUS.FULL) {
      console.log('Diff url returns full file...');
      const fullFileString = patchResponse.data.content;
      return validateFullFile(fullFileString, newFileString);
    } else if (status === STARK_DIFF_STATUS.PATCH) {
      const patchString = patchResponse.data.content;
      const targetChecksum = patchResponse.data.newFileChecksum;
      return validatePatch(oldFileString, newFileString, patchString, targetChecksum);
    } else {
      console.log('Unknow diff status in response', status);
      return false;
    }
  });
}

function validateFileByUrl(fileUrl, filePath) {
  const localContentPromise = new Promise((resolve, reject) => {
    fs.readFile(filePath, {
      encoding: 'utf8',
    }, (err, content) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(content);
    });
  });

  return Promise.all([localContentPromise, axios.get(fileUrl)])
    .then(([localContent, response]) => {
      const remoteContent = response.data;
      return validateFullFile(remoteContent, localContent);
    });
}

module.exports = {
  parsePatchUrl,
  validatePatch,
  validatePatchByUrl,
  validateFileByUrl,
};