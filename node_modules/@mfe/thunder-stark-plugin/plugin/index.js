const fs = require('fs')
const { resolve, relative } = require('path');
const { uploadStaticFiles, DEFAULT_STATIC_UPLOAD_URL } = require('@mfe/stark-uploader')
const DEFAULT_BLACKLIST = [
  /\.git/,
  /thunder-state/,
  /service-worker/,
  /\.DS_Store/,
  /\.log$/,
  /\.map$/,
];
/**
* {
*   "address": "//stark-mixer.zc.st.sankuai.com/diff/",
*   "fallback": "https://s3plus.meituan.net/v1/mss_e2821d7f0cfe4ac1bf9202ecf9590e67/diff-prod/file:c25922b8:cdn/",
*   "projectName": "c25922b8",
*   "dist": "dist",
*   "uploadUrl": "http://diffadmin.sankuai.com/shell/upload/",
* }
*/
function isEntryHitBlacklist(entryPath, blacklist) {
  if (!Array.isArray(blacklist)) {
    return false;
  }

  return blacklist.filter((item) => {
    const rex = new RegExp(item);
    return entryPath.match(rex);
  }).length > 0;
}
function assembleDirFiles(dirBase, dirPath, blacklist) {
  const collectedFiles = [];
  const entries = fs.readdirSync(dirPath);
  for (let index = 0; index < entries.length; index++) {
    const entry = entries[index];
    const entryPath = resolve(dirPath, entry);

    if (isEntryHitBlacklist(relative(dirBase, entryPath), blacklist)) {
      console.log(`File "${entryPath}" hit blacklist, will NOT be uploaded!`);
      continue;
    }

    const stat = fs.statSync(entryPath);

    if (stat.isFile()) {
      collectedFiles.push({
        filePath: entryPath,
        fileName: relative(dirBase, entryPath)
      });
      continue;
    }

    if (stat.isDirectory()) {
      const subFiles = assembleDirFiles(dirBase, entryPath, blacklist);
      collectedFiles.push(...subFiles);
      continue;
    }
  }
  return collectedFiles;
}

function upload({ projectName, dist, uploadUrl, uploadBlacklist }) {
  if (!projectName) {
    throw new Error('projectName is invalid')
  }
  const resolvedBlacklist = uploadBlacklist || DEFAULT_BLACKLIST;
  const files = assembleDirFiles(dist, dist, resolvedBlacklist);
  return uploadStaticFiles(files, projectName, uploadUrl || DEFAULT_STATIC_UPLOAD_URL);
}


function readState(thunderStatePath) {
  const content = fs.readFileSync(thunderStatePath, 'utf8')
  if (!content) {
    throw new Error(`content of ${thunderStatePath} is empty`)
  }

  try {
    return JSON.parse(content)
  } catch (e) {
    throw new Error('failed at parsing thunder state file')
  }
}

function uploadToStark(thunderStatePath) {
  const thunderState = readState(thunderStatePath)
  if (!thunderState || !thunderState.StarkOptions) {
    throw new Error('invalid StarkOptions')
  }

  console.log('\nUploading files to Stark...\n')
  return upload(thunderState.StarkOptions)
}

module.exports = {
  uploadToStark: uploadToStark,
}
