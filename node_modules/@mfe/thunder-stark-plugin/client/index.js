const CheckInBrowser = typeof window !== 'undefined'
const SupportPerformance = CheckInBrowser && 'performance' in window && 'now' in performance

function timeNow() {
  if (SupportPerformance) return Math.floor(performance.now())
  return Date.now()
}

const DEFAULT_ADDRESS = 'https://jarvas-static.meituan.net/diff/'
const DEFAULT_FALLBACK = '//jarvas-static.meituan.net/file/PROJECT_NAME?filePath='

const STARK_DIFF_STATUS = {
  PATCH: 2,
  FULL: 1,
  FAILED: 0
}
const STARK_DIFF_CODE = {
  CLIENT_PATCH_ERROR: 416,
  CHECKSUM_FAILED: 409,
  UNKNOWN_ERROR: 400,
  LOCAL_VERSION_NOT_FOUND: 205
}

function StarkError(message, code, result) {
  this.message = message
  this.statusCode = code
  this.result = result || {}
}

StarkError.prototype = new Error()
StarkError.prototype.constructor = StarkError

/**
* recoverMin
* @param {string} source         LS中的缓存源文件
* @param {string} patchContent   Stark服务器返回的patch文件
* @return {Object} content: 新文件内容, fullLength全量大小, patchLength补丁大小
*/
export function recoverMin(source = '', patchContent = '') {
  const units = patchContent.split('\t')
  let content = source
  let pos = 0

  const start = timeNow()

  for (let i = 0; i < units.length; i++) {
    const command = units[i][0]
    if (command === '=') {
      pos += parseInt(units[i].slice(1), 10)
    } else if (command === '-') {
      let length = parseInt(units[i].slice(1), 10)
      content = content.slice(0, pos) + content.slice(pos + length)
    } else if (command === '+') {
      let newPartial = decodeURI(units[i].slice(1))
      content = content.slice(0, pos) + newPartial + content.slice(pos)
      pos += newPartial.length
    } else {
      throw new StarkError('Broken patch found', STARK_DIFF_CODE.CLIENT_PATCH_ERROR)
    }
  }

  return {
    content,
    fullLength: content.length,
    patchLength: patchContent.length,
    recoverCost: timeNow() - start
  }
}

export function handleResponse(responseText, source) {
  const patchJson = JSON.parse(responseText)
  let result

  if (patchJson.status === STARK_DIFF_STATUS.FAILED) {
    throw new StarkError('Stark service down', patchJson.code)
  }
  if (patchJson.status === STARK_DIFF_STATUS.FULL) {
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: patchJson.content,
      fullLength: patchJson.content.length,
      patchLength: patchJson.content.length,
      checksum: patchJson.newFileChecksum
    }
  }
  if (patchJson.status === STARK_DIFF_STATUS.PATCH) {
    const recoverResult = recoverMin(source, patchJson.content)
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: recoverResult.content,
      fullLength: recoverResult.fullLength,
      patchLength: recoverResult.patchLength,
      checksum: patchJson.newFileChecksum
    }
  }

  return result
}

export function genStarkLink(chunkName, localChunk, remoteChunk, options = {}) {
  const { address, projectName } = options
  const realAddress = address || DEFAULT_ADDRESS

  if (!localChunk || !localChunk.hash) {
    return
  }

  const oldFilePath = localChunk.filename
  const newFilePath = remoteChunk.filename

  const oldFilePathParam = encodeURIComponent(oldFilePath)
  const newFilePathParam = encodeURIComponent(newFilePath)

  return `${realAddress}${projectName}?oldFilePath=${oldFilePathParam}&newFilePath=${newFilePathParam}`
}

export class StarkUpdatePlugin {
  constructor(chunkName, { localChunk, remoteChunk }, options, helpers) {
    this.chunkName = chunkName
    this.localChunk = localChunk || {}
    this.remoteChunk = remoteChunk
    this.options = options
    this.helpers = helpers
  }

  report({ status, statusCode, loadCost }, result) {
    const chunkName = this.chunkName
    const localChunk = this.localChunk
    const remoteHash = this.remoteChunk.hash || this.remoteChunk.filename

    this.helpers.logger.markOnce('stark:' + chunkName, {
      channel: 'lx',
      appKey: this.options.projectName, // 项目key,即管理系统生成的项目appkey
      fileName: chunkName, // 文件名字
      currentVersion: localChunk.hash, // 当前资源版本
      diffVersion: remoteHash, // 需要diff的版本
      saveSize: Math.max(result.fullLength - result.patchLength, 0), // diff节省的流量
      diffState: status,
      diffDetailState: statusCode,
      patchLength: result.patchLength,
      fullLength: result.fullLength,
      recoverCost: result.recoverCost,
      loadCost: loadCost,
      checksum: result.checksum
    }, false)
  }

  getDiff() {
    const chunkName = this.chunkName
    const localChunk = this.localChunk
    const remoteHash = this.remoteChunk.hash
    const link = genStarkLink(chunkName, this.localChunk, this.remoteChunk, this.options)

    if (!localChunk || !localChunk.filename || !localChunk.content) return this.helpers.Promise.resolve()
    const start = timeNow()
    return this.helpers.request(link)
      .then(responseText => {
        const result = handleResponse(responseText, localChunk.content)

        const {
          status,
          statusCode,
          content
        } = result

        this.report({
          status: status,
          statusCode: statusCode,
          loadCost: timeNow() - start
        }, result)

        return content
      })
      .then(content => {
        return {
          name: chunkName,
          content,
          hash: remoteHash,
          from: 'diff'
        }
      }, err => {
        this.helpers.debug('error', 'getDiff failed', err)
        let statusCode
        if (!localChunk.hash) {
          statusCode = STARK_DIFF_CODE.LOCAL_VERSION_NOT_FOUND
        } else {
          statusCode = err.statusCode || STARK_DIFF_CODE.UNKNOWN_ERROR
        }

        const result = err && err.result || {}

        this.report({
          status: STARK_DIFF_STATUS.FAILED,
          statusCode: statusCode
        }, result)

        return this.helpers.Promise.resolve()
      })
  }
}

export function StarkUpdate(chunkName, chunkData, thunder, helpers) {
  if (!thunder.state.StarkOptions) return helpers.Promise.resolve()
  const { projectName, fallback } = thunder.state.StarkOptions
  const realFallback = fallback || DEFAULT_FALLBACK.replace('PROJECT_NAME', projectName)

  thunder.set({
    fallbackCDN: realFallback
  })
  const starkUpdator = new StarkUpdatePlugin(chunkName, chunkData, thunder.state.StarkOptions, helpers)
  return starkUpdator.getDiff()
}

export default function install(Thunder) {
  Thunder.prototype._updateAdapter = StarkUpdate
}
