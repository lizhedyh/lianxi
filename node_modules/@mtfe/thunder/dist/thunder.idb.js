/*!
 * Thunder.js v2.3.7
 * (c) 2019-07-02 14:28:13 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Thunder = factory());
}(this, (function () { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/*
  es6-promise-polyfill
  v1.2.0 (c) lahmatiy
  MIT License https://github.com/lahmatiy/es6-promise-polyfill
*/
/* istanbul ignore next */
var Promise$1 = function (global) {
  //
  // Check for native Promise and it has correct interface
  //

  var NativePromise = global['Promise'];
  var nativePromiseSupported = NativePromise &&
  // Some of these methods are missing from
  // Firefox/Chrome experimental implementations
  'resolve' in NativePromise && 'reject' in NativePromise && 'all' in NativePromise && 'race' in NativePromise &&
  // Older version of the spec had a resolver object
  // as the arg rather than a function
  function () {
    var resolve;
    // eslint-disable-next-line
    new NativePromise(function (r) {
      resolve = r;
    });
    return typeof resolve === 'function';
  }();

  //
  // Polyfill
  //

  var PENDING = 'pending';
  var SEALED = 'sealed';
  var FULFILLED = 'fulfilled';
  var REJECTED = 'rejected';
  var NOOP = function NOOP() {};

  function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
  }

  // async calls
  var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
  var asyncQueue = [];
  var asyncTimer;

  function asyncFlush() {
    // run promise callbacks
    for (var i = 0; i < asyncQueue.length; i++) {
      asyncQueue[i][0](asyncQueue[i][1]);
    }

    // reset async asyncQueue
    asyncQueue = [];
    asyncTimer = false;
  }

  function asyncCall(callback, arg) {
    asyncQueue.push([callback, arg]);

    if (!asyncTimer) {
      asyncTimer = true;
      asyncSetTimer(asyncFlush, 0);
    }
  }

  function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
      resolve(promise, value);
    }

    function rejectPromise(reason) {
      reject(promise, reason);
    }

    try {
      resolver(resolvePromise, rejectPromise);
    } catch (e) {
      rejectPromise(e);
    }
  }

  function invokeCallback(subscriber) {
    var owner = subscriber.owner;
    var settled = owner.state_;
    var value = owner.data_;
    var callback = subscriber[settled];
    var promise = subscriber.then;

    if (typeof callback === 'function') {
      settled = FULFILLED;
      try {
        value = callback(value);
      } catch (e) {
        reject(promise, e);
      }
    }

    if (!handleThenable(promise, value)) {
      if (settled === FULFILLED) {
        resolve(promise, value);
      }

      if (settled === REJECTED) {
        reject(promise, value);
      }
    }
  }

  function handleThenable(promise, value) {
    var resolved;

    try {
      if (promise === value) {
        throw new TypeError('A promises callback cannot return that same promise.');
      }

      if (value && (typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {
        var then = value.then; // then should be retrived only once

        if (typeof then === 'function') {
          then.call(value, function (val) {
            if (!resolved) {
              resolved = true;

              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }
          }, function (reason) {
            if (!resolved) {
              resolved = true;

              reject(promise, reason);
            }
          });

          return true;
        }
      }
    } catch (e) {
      if (!resolved) {
        reject(promise, e);
      }

      return true;
    }

    return false;
  }

  function resolve(promise, value) {
    if (promise === value || !handleThenable(promise, value)) {
      fulfill(promise, value);
    }
  }

  function fulfill(promise, value) {
    if (promise.state_ === PENDING) {
      promise.state_ = SEALED;
      promise.data_ = value;

      asyncCall(publishFulfillment, promise);
    }
  }

  function reject(promise, reason) {
    if (promise.state_ === PENDING) {
      promise.state_ = SEALED;
      promise.data_ = reason;

      asyncCall(publishRejection, promise);
    }
  }

  function publish(promise) {
    var callbacks = promise.then_;
    promise.then_ = undefined;

    for (var i = 0; i < callbacks.length; i++) {
      invokeCallback(callbacks[i]);
    }
  }

  function publishFulfillment(promise) {
    promise.state_ = FULFILLED;
    publish(promise);
  }

  function publishRejection(promise) {
    promise.state_ = REJECTED;
    publish(promise);
  }

  /**
  * @class
  */
  function Promise(resolver) {
    if (typeof resolver !== 'function') {
      throw new TypeError('Promise constructor takes a function argument');
    }

    if (this instanceof Promise === false) {
      throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    }

    this.then_ = [];

    invokeResolver(resolver, this);
  }

  Promise.prototype = {
    constructor: Promise,

    state_: PENDING,
    then_: null,
    data_: undefined,

    then: function then(onFulfillment, onRejection) {
      var subscriber = {
        owner: this,
        then: new this.constructor(NOOP),
        fulfilled: onFulfillment,
        rejected: onRejection
      };

      if (this.state_ === FULFILLED || this.state_ === REJECTED) {
        // already resolved, call callback async
        asyncCall(invokeCallback, subscriber);
      } else {
        // subscribe
        this.then_.push(subscriber);
      }

      return subscriber.then;
    },

    'catch': function _catch(onRejection) {
      return this.then(null, onRejection);
    }
  };

  Promise.all = function (promises) {
    var Class = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.all().');
    }

    return new Class(function (resolve, reject) {
      var results = [];
      var remaining = 0;

      function resolver(index) {
        remaining++;
        return function (value) {
          results[index] = value;
          if (! --remaining) {
            resolve(results);
          }
        };
      }

      for (var i = 0, promise; i < promises.length; i++) {
        promise = promises[i];

        if (promise && typeof promise.then === 'function') {
          promise.then(resolver(i), reject);
        } else {
          results[i] = promise;
        }
      }

      if (!remaining) {
        resolve(results);
      }
    });
  };

  Promise.race = function (promises) {
    var Class = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.race().');
    }

    return new Class(function (resolve, reject) {
      for (var i = 0, promise; i < promises.length; i++) {
        promise = promises[i];

        if (promise && typeof promise.then === 'function') {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
    });
  };

  Promise.resolve = function (value) {
    var Class = this;

    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Class) {
      return value;
    }

    return new Class(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (reason) {
    var Class = this;

    return new Class(function (resolve, reject) {
      reject(reason);
    });
  };

  return nativePromiseSupported ? NativePromise : Promise;
}(typeof window !== 'undefined' ? window : typeof global !== 'undefined' && global || {});

var isBrowser = typeof window !== 'undefined';

// inspired by https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
var supportLS = function (storage) {
  if (!storage) return false;
  try {
    var key = '__LS_SUPPORT_TEST_KEY__';
    storage.setItem(key, key);
    storage.removeItem(key, key);
    return true;
  } catch (e) {
    return false;
  }
}(window.localStorage);

var isDEBUG = isBrowser && 'DEBUG_THUNDER' in window && window.DEBUG_THUNDER;
var supportFetch = isBrowser && 'fetch' in window;
var isUnitTest = isBrowser && 'UNIT_TEST_THUNDER' in window && window.UNIT_TEST_THUNDER;

var requestDefault = {
  method: 'GET',
  data: null,
  url: ''
};

function baseFetch(options, callback) {
  window.fetch(options.url, {
    method: options.method,
    body: options.body
  }).then(function (res) {
    if (!res.ok) return callback(res);
    return res.text();
  }).then(function (content) {
    callback(null, content);
  }).catch(callback);
}

function baseXMLHttpRequest(options, callback) {
  var xhr = new window.XMLHttpRequest();
  xhr.withCredentials = false;
  xhr.open(options.method, options.url, true);
  xhr.onreadystatechange = function () {
    // load end
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        xhr.onreadystatechange = null;
        callback(null, xhr.responseText);
      } else {
        // ajax load failed
        callback(new Error('ThunderError: content load failed'));
      }
    }
  };
  xhr.send(options.body);
}

/*
* request
* @param options : String or Object
* @param cb : Function
*/
function _request(_options, callback) {
  if (!isBrowser) return callback(new Error('ThunderError: not in browser'));
  var options = {
    method: 'GET',
    data: null,
    url: '',
    body: undefined
  };
  if (typeof _options === 'string') {
    options.url = _options;
  } else {
    assign(options, _options);
  }
  // set default method
  if (!options.method) options.method = requestDefault.method;

  // force set uppercase
  options.method = options.method.toUpperCase();

  // format data to stringify body
  if (options.data) {
    options.body = JSON.stringify(options.data);
  }

  if (supportFetch) {
    return baseFetch(options, callback);
  }

  return baseXMLHttpRequest(options, callback);
}

function request(options) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

  return new Promise(function (resolve, reject) {
    _request(options, function (err, content) {
      if (err) {
        cb(err);
        reject(err);
      } else {
        cb(null, content);
        resolve(content);
      }
    });
  });
}

function execModule(content, type, attrs) {
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;
  if (type === 'js') {
    el = document.createElement('script');
    el.type = 'text/javascript';
    el.charset = 'utf-8';
    el.text = content;
  } else {
    el = document.createElement('style');
    el.type = 'text/css';
    el.charset = 'utf-8';
    el.textContent = content;
  }
  if (attrs) {
    keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }
  head.appendChild(el);
  if (typeof el.onload === 'function') el.onload();
  return el;
}

function getScriptElement(link) {
  var el = document.createElement('script');
  el.type = 'text/javascript';
  el.charset = 'utf-8';
  el.async = true;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function getLinkElement(link) {
  var el = document.createElement('link');
  el.rel = 'stylesheet';
  el.href = link;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function execModuleAsyncLoad(link, type, attrs, callback) {
  // start chunk loading
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;

  if (type === 'js') {
    el = getScriptElement(link);
    if (attrs) {
      keys(attrs).forEach(function (key) {
        el.setAttribute(key, attrs[key]);
      });
    }
  } else if (type === 'css') {
    el = getLinkElement(link);
  }

  if (!el) return callback(new Error('execModuleAsyncLoad: wrong type with ' + type));
  var _onerror = noop;
  var _onload = noop;

  if (typeof el.onerror === 'function') _onerror = el.onerror;
  if (typeof el.onload === 'function') _onload = el.onload;

  el.onerror = onScriptError;
  el.onload = onScriptComplete;

  var timer = setTimeout(function () {
    onScriptError(new Error('execModuleAsyncLoad: timeout ' + link));
  }, 120000);

  function onScriptError(msg) {
    _onerror();
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(msg);
  }

  function onScriptComplete() {
    _onload();
    // avoid mem leaks in IE.
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(null, el);
  }
  head.appendChild(el);
  return el;
}

function debug() {
  /* istanbul ignore next */
  if (!isDEBUG) return;

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var type = args[0];
  var logger = void 0;
  /* istanbul ignore if */
  if (console[type]) {
    logger = console[type];
    args.shift();
  } else {
    logger = console.log;
  }
  args.unshift('[Thunder]');
  logger.apply(console, args);
}

function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function keys(obj) {
  if (!isUnitTest && Object.keys) return Object.keys(obj);
  if (obj !== Object(obj)) {
    throw new TypeError('Object.keys called on a non-object');
  }
  var keys = [];
  var key = void 0;
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
}

function noop() {}



var fakeLogger = {
  markOnce: noop,
  mark: noop,
  markEnd: noop
};

// Copyright (C) 2014-present  SheetJS

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// modify by longjiawen@meituan.com

var T = signedCrcTable();

function signedCrcTable() {
  var c = 0;
  var table = new Array(256);

  for (var n = 0; n !== 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }

  return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

function crc32Str(str, seed) {
  var C = seed ^ -1;
  for (var i = 0, L = str.length, c, d; i < L;) {
    c = str.charCodeAt(i++);
    if (c < 0x80) {
      C = C >>> 8 ^ T[(C ^ c) & 0xFF];
    } else if (c < 0x800) {
      C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    } else if (c >= 0xD800 && c < 0xE000) {
      c = (c & 1023) + 64;d = str.charCodeAt(i++) & 1023;
      C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 0xFF];
    } else {
      C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    }
  }
  return (C ^ -1) >>> 0;
}

var Chunk = function () {
  function Chunk(name, state, options) {
    classCallCheck(this, Chunk);

    this.type = '';
    this.name = name;
    this.state = state;
    this.options = options;
    this.store = options.store;
    this.logger = options.logger;
    this._updateAdapter = options.updateAdapter;
    this._content = '';
  }

  createClass(Chunk, [{
    key: 'load',
    value: function load() {
      return this.getContent().then(noop, function (e) {
        console.error(e);
        // 获取失败时跳过，在 render 中执行缺少 content, 会执行 JSONP fallback
      });
    }
  }, {
    key: 'check',
    value: function check() {
      // if state.checksum is not exist, just skip
      // 例如：外链资源
      if (typeof this.state.checksum === 'undefined') return true;

      this.logger.mark('check:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'chunkChecksum',
        size: Math.floor(this._content.length / 1024),
        originChecksum: this.state.checksum,
        reportCost: true
      });
      var checksum = crc32Str(this._content);
      var isMatch = checksum === this.state.checksum;
      this.logger.markEnd('check:' + this.cacheKey, {
        isMatch: isMatch,
        currentChecksum: checksum
      });

      if (isMatch) return isMatch;
      // if not match，call clear
      this.store.remove(this.cacheKey);
      return false;
    }
  }, {
    key: '_request',
    value: function _request$$1() {
      var _this = this;

      // read from HTTP
      return new Promise(function (resolve, reject) {
        request(_this.link, function (err, content) {
          if (err) {
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullFailure',
              reportCost: true
            });
            return reject(err);
          } else {
            _this._content = content;
            _this.store.add({
              name: _this.cacheKey,
              hash: _this.hash,
              cacheAge: _this.state.cacheAge || _this.options.cacheAge,
              content: _this._content,
              filename: _this.filename
            });
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullSuccess',
              reportCost: true
            });
            resolve(content);
          }
        });
      });
    }
  }, {
    key: 'update',
    value: function update(cached) {
      var _this2 = this;

      return this._updateAdapter(this.name, {
        localChunk: cached,
        remoteChunk: this.state
      }).then(function (payload) {
        // diff failed or skiped
        if (!payload || !payload.content) return _this2._request();

        // diff success
        _this2._content = payload.content;
        _this2.store.add({
          name: _this2.cacheKey,
          hash: _this2.hash,
          cacheAge: _this2.state.cacheAge || _this2.options.cacheAge,
          content: _this2._content,
          filename: _this2.filename
        });
        return _this2._content;
      }, function (e) {
        // diff failed
        console.error(e);
        return _this2._request();
      });
    }
  }, {
    key: 'getContent',
    value: function getContent() {
      var _this3 = this;

      if (this._content) return Promise.resolve(this._content);
      this.logger.markOnce('request:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'request'
      });
      this.logger.mark('async:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reportCost: true
      });
      // read from CacheStore
      return this.store.get(this.cacheKey).then(function (cached) {
        // no cache
        // read from HTTP
        if (!cached) return _this3._request();

        // has local Cache
        var content = cached.content,
            hash = cached.hash;
        // version matched

        if (_this3.hash === hash) {
          _this3.logger.markEnd('async:' + _this3.cacheKey, {
            reason: _this3.store.type,
            reportCost: true
          });
          _this3._content = content;
          return Promise.resolve(_this3._content);
        } else {
          // version not matched, try update
          return _this3.update(cached);
        }
      });
    }
  }, {
    key: 'fallback',
    value: function fallback() {
      var _this4 = this;

      var execFallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModuleAsyncLoad;

      this.logger.mark('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'fallbackStart'
      });
      return new Promise(function (resolve, reject) {
        // fallback
        execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (err) {
          // success
          if (!err) {
            _this4.fallbackState = 'fallbackSuccessFrist';
            return resolve();
          }
          // try again fallback link
          execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (reErr) {
            if (!reErr) {
              _this4.fallbackState = 'fallbackSuccessSecond';
              return resolve();
            }
            _this4.fallbackState = 'fallbackFailure';
            reject(reErr);
          });
        });
      });
    }
  }, {
    key: 'cacheKey',
    get: function get$$1() {
      return '<' + this.type + '>:' + this.name;
    }
  }, {
    key: 'hash',
    get: function get$$1() {
      return this.state.hash || this.filename || this.link;
    }
  }, {
    key: 'link',
    get: function get$$1() {
      if (this.state.link) {
        return this.state.link;
      } else {
        return this.options.config.publicPath + this.filename;
      }
    }
  }, {
    key: 'fallbackState',
    set: function set$$1(value) {
      this.logger.markEnd('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: value
      });
    }
  }, {
    key: 'fallbackLink',
    get: function get$$1() {
      // if link exist (外链资源), use link
      if (this.state.link) {
        return this.state.link;
      } else {
        // if fallbackCDN doesn't exist, use publicPath instead
        return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename;
      }
    }
  }, {
    key: 'attrs',
    get: function get$$1() {
      return assign({
        'thunder-cache-key': this.cacheKey,
        'crossorigin': this.options.config.crossOriginLoading
      }, this.options.attrs, this.state.attrs);
    }
  }]);
  return Chunk;
}();

var JSStaticType = 'js';

var ScriptChunk = function (_Chunk) {
  inherits(ScriptChunk, _Chunk);

  function ScriptChunk(name, state, options) {
    classCallCheck(this, ScriptChunk);

    var _this = possibleConstructorReturn(this, (ScriptChunk.__proto__ || Object.getPrototypeOf(ScriptChunk)).call(this, name, state, options));

    _this.type = JSStaticType;
    return _this;
  }

  createClass(ScriptChunk, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(execModule(this._content, 'js', this.attrs)).then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      } else {
        // 1. 没有 _content, 加载失败
        // 2. checksum 校验和不匹配
        return this.fallback().then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return JSStaticType;
    }
  }]);
  return ScriptChunk;
}(Chunk);

var CSSStaticType = 'css';

var StyleChunk = function (_Chunk) {
  inherits(StyleChunk, _Chunk);

  function StyleChunk(name, state, options) {
    classCallCheck(this, StyleChunk);

    var _this = possibleConstructorReturn(this, (StyleChunk.__proto__ || Object.getPrototypeOf(StyleChunk)).call(this, name, state, options));

    _this.type = CSSStaticType;
    return _this;
  }

  createClass(StyleChunk, [{
    key: 'render',


    /*
    * render
    * @param exec
    * @param execFallback
    */
    value: function render() {
      var exec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModule;
      var execFallback = arguments[1];

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(exec(this._content, 'css', this.attrs));
      } else {
        return this.fallback(execFallback);
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return CSSStaticType;
    }
  }]);
  return StyleChunk;
}(Chunk);

var Thunder$1 = function () {
  function Thunder(state) {
    classCallCheck(this, Thunder);

    this.state = state;
    this.version = '2.3.7';
    this.running = true;
    this.type = 'tiny';
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : '';
    this._chunks = [];
    this.init();
  }

  createClass(Thunder, [{
    key: 'set',
    value: function set$$1() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          nonce = _ref.nonce,
          publicPath = _ref.publicPath,
          attrs = _ref.attrs,
          fallbackCDN = _ref.fallbackCDN;

      if (nonce) this._chunkOptions.attrs.nonce = nonce;
      if (attrs) assign(this._chunkOptions.attrs, attrs);
      if (publicPath) this._chunkOptions.config.publicPath = publicPath;
      if (fallbackCDN) this._chunkOptions.config.fallbackCDN = fallbackCDN;
    }
  }, {
    key: 'init',
    value: function init() {
      var _this = this;

      if (isBrowser) {
        window.__thunder__ = this;
      }
      Thunder._installedPlugins.forEach(function (plugin) {
        return plugin(_this);
      });
      if (!this.logger) this.logger = fakeLogger;
      this._chunkOptions = {
        attrs: assign({}, this.state.outputOptions.attrs),
        config: this.state.outputOptions,
        cacheAge: this.state.cacheAge,
        store: this.store,
        logger: this.logger,
        updateAdapter: this.updateAdapter.bind(this)
        // match resource
        // js -> create scriptChunk instance
        // css -> create styleChunk instance
      };this.state.resources.forEach(function (resource) {
        Thunder.Chunks.forEach(function (ChunkConstructor) {
          if (resource.type !== ChunkConstructor.type) return;
          _this._chunks.push(new ChunkConstructor(resource.name, resource, _this._chunkOptions));
        });
      });
      // prepare clear unexist chunk cache
      this.store.saveChunksMap(this._chunks.map(function (c) {
        return c.cacheKey;
      }));

      this.logger.markOnce('init', {
        channel: 'lx',
        SWSupport: this.serviceWorkerManager && this.serviceWorkerManager.isSupport(),
        useSW: !!this.state.serviceWorker,
        reason: 'init'
      });
    }
  }, {
    key: 'updateAdapter',
    value: function updateAdapter(chunkName, preUpdateData) {
      if (!this._updateAdapter) return Promise.resolve();
      return this._updateAdapter(chunkName, preUpdateData, this, {
        Promise: Promise,
        request: request,
        debug: debug,
        logger: this.logger
      });
    }
  }, {
    key: 'bundleLoader',
    value: function bundleLoader(chunkName) {
      return this.parallel(chunkName);
    }
  }, {
    key: 'styleLoader',
    value: function styleLoader(chunkName) {
      return this.parallelStyle(chunkName);
    }
  }, {
    key: 'parallelStyle',
    value: function parallelStyle(chunkNames) {
      return this.parallel(chunkNames, 'css');
    }
  }, {
    key: 'load',
    value: function load(jobs, cb) {
      var _this2 = this;

      var queue = Promise.resolve();
      // load
      jobs.forEach(function (job) {
        job.action = job.action || 'load';
        if (job.action === 'load') {
          queue = queue.then(function () {
            return _this2.parallel(job.chunks, job.type);
          });
        }
      });
      // prefetch
      jobs.forEach(function (job) {
        if (job.action === 'prefetch') {
          queue = queue.then(function () {
            return _this2.prefetch(job.chunks, job.type);
          });
        }
      });
      queue.then(function () {
        if (cb) cb();
      });
      return queue;
    }
  }, {
    key: 'parallel',
    value: function parallel(chunkNames, type) {
      var chunks = this._getChunks(chunkNames, type);

      return Promise.all(chunks.map(function (c) {
        return c.load();
      })).then(function () {
        var queue = Promise.resolve();
        chunks.forEach(function (c) {
          queue = queue.then(function () {
            return c.render();
          });
        });
        return queue;
      }).catch(function (err) {
        return console.error(err);
      });
    }
  }, {
    key: 'prefetch',
    value: function prefetch() {
      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // delay 500ms
      var prefetchChunks = this._getChunks(chunks);
      prefetchChunks = prefetchChunks.concat(this._getChunks(chunks, 'css'));
      return new Promise(function (resolve, reject) {
        setTimeout(resolve, 500);
      }).then(function () {
        var unloadChunks = [];
        prefetchChunks.map(function (c) {
          if (!c._content) unloadChunks.push(c);
        });
        return Promise.all(unloadChunks.map(function (c) {
          return c.getContent();
        }));
      });
    }

    /*
    * @internal
    * _getChunks
    * @param chunkNames <String> Array or String
    * @param type String
    * @return <Chunk> Array
    */

  }, {
    key: '_getChunks',
    value: function _getChunks(_chunkNames) {
      var _this3 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'js';

      var chunkNames = void 0;
      var chunks = [];

      if (typeof _chunkNames === 'string') {
        chunkNames = [_chunkNames];
      } else {
        chunkNames = _chunkNames;
      }

      chunkNames.forEach(function (name) {
        _this3._chunks.forEach(function (c) {
          if (c.type === type && name === c.name) {
            chunks.push(c);
          }
        });
      });

      return chunks;
    }
  }]);
  return Thunder;
}();

Thunder$1.StyleChunk = StyleChunk;
Thunder$1.ScriptChunk = ScriptChunk;
Thunder$1.BaseChunk = Chunk;
Thunder$1.Chunks = [StyleChunk, ScriptChunk];

Thunder$1._installedPlugins = [];

Thunder$1.use = function use() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var plugin = args.shift();
  var installedPlugins = this._installedPlugins;
  if (!plugin || installedPlugins.indexOf(plugin) > -1) {
    return this;
  }
  // args.unshift(this)
  // if (typeof plugin.install === 'function') {
  //   plugin.install.apply(plugin, args)
  // } else if (typeof plugin === 'function') {
  //   plugin.apply(null, args)
  // }
  installedPlugins.push(plugin);
  return this;
};

var supportPerformance = isBrowser && 'performance' in window && 'now' in performance;

function getRandomInt() {
  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;

  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function fakeId() {
  var i = 16;
  var id = '';
  while (i--) {
    id += '' + getRandomInt();
  }
  return id;
}

function timeNow() {
  if (supportPerformance) return performance.now();
  return Date.now();
}

var LXReporter = function () {
  function LXReporter() {
    classCallCheck(this, LXReporter);

    this.logQueue = [];
    this._timer = null;
    this._delay = 100;
    this._url = '//report.meituan.com';
    this.report = this.report.bind(this);
  }

  createClass(LXReporter, [{
    key: '_report',
    value: function _report() {
      var _this = this;

      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

      var msid = fakeId();
      var uuid = fakeId();
      var lxCuid = document.cookie.replace(/(?:(?:^|.*;\s*)_lxsdk_cuid\s*=\s*([^;]*).*$)|^.*$/, '$1');

      var logs = this.logQueue.map(function (data) {
        var seq = fakeId().slice(0, 4);
        var reqId = fakeId();

        // 增加灵犀 trace id 上报
        data.lxid = lxCuid;

        return {
          'req_id': reqId,
          'val_cid': data.cid ? data.cid : 'c_c4nzgz77',
          'nt': 0,
          'isauto': 7,
          'tm': data.createdAt,
          'val_lab': data,
          'val_bid': data.bid || 'b_w006udto',
          'seq': +seq,
          'nm': 'MV'
        };
      });

      return request({
        url: this._url,
        method: 'post',
        data: [{
          'category': 'data_sdk_smartpay',
          'sdk_ver': '4.3.0',
          'ct': 'www',
          'ch': 'web',
          'ua': navigator && navigator.userAgent,
          'sc': '640*360',
          'uuid': uuid,
          'lxid': lxCuid,
          'msid': msid,
          'appnm': 'qrcode_pay_fe',
          'evs': logs
        }]
      }).then(function () {
        _this.logQueue.length = 0;
        fn();
      }).catch(function (err) {
        if (err) console.log(err);
        fn(err);
      });
    }
  }, {
    key: 'report',
    value: function report(data, fn) {
      var _this2 = this;

      data.createdAt = Date.now();
      this.logQueue.push(data);
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(function () {
        _this2._timer = null;
        _this2._report(fn);
      }, this._delay);
    }
  }]);
  return LXReporter;
}();

var lxReporter = new LXReporter();

// import owl from './owl-report'

var Logger = function () {
  function Logger(_ref) {
    var project = _ref.project,
        version = _ref.version,
        starkAppKey = _ref.starkAppKey;
    classCallCheck(this, Logger);

    this.project = project;
    this.version = version;
    this.starkAppKey = starkAppKey;
    this.logQueue = [];
    this.markQueue = {};
    this._reporters = [{
      reporter: lxReporter.report,
      channel: 'lx'
    }];
    this._timer = null;
  }

  createClass(Logger, [{
    key: 'use',
    value: function use(fn, channel) {
      if (typeof fn !== 'function') return;
      var has = false;
      this._reporters.map(function (ctx) {
        if (ctx.reporter === fn) has = true;
      });
      if (!has) {
        this._reporters.push({
          channel: channel,
          reporter: fn
        });
      }
    }
  }, {
    key: 'mark',
    value: function mark(key) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!key) return;
      this.markQueue[key] = {
        createdAt: timeNow(),
        data: data
      };
    }
  }, {
    key: 'markEnd',
    value: function markEnd(key, data, noInject) {
      var mark = this.markQueue[key];
      if (!mark) return;
      var now = timeNow();
      var cost = now - mark.createdAt;
      var log = {
        key: key,
        data: assign(noInject ? {} : {
          project: this.project,
          starkAppKey: this.starkAppKey,
          cost: cost,
          name: key,
          version: this.version
        }, mark.data, data)
      };

      if (log.error) {
        return console.log(log.err);
      }

      if (log.data.cost) {
        log.data.cost = Math.floor(log.data.cost);
      }

      this.logQueue.push(log);
      delete this.markQueue[key];
      this.report();
    }
  }, {
    key: 'markOnce',
    value: function markOnce(key, data, noInject) {
      this.mark(key, data);
      this.markEnd(key, data, noInject);
    }
  }, {
    key: 'report',
    value: function report() {
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(this._report.bind(this), 300);
    }
  }, {
    key: '_report',
    value: function _report() {
      var _this = this;

      this._timer = null;
      this.logQueue.forEach(function (log) {
        if (!log.data) return;
        _this._reporters.forEach(function (ctx) {
          if (log.data.channel) {
            if (ctx.channel === log.data.channel) {
              ctx.reporter(log.data);
            }
          } else {
            ctx.reporter(log.data);
          }
        });
      });

      this.logQueue.length = 0;
    }
  }]);
  return Logger;
}();

var Logger$1 = (function (thunder) {
  thunder.logger = new Logger({
    version: thunder.version,
    project: thunder.state.project,
    starkAppKey: thunder.starkAppKey
  });
});

function toArray$1(arr) {
    return Array.prototype.slice.call(arr);
}

function promisifyRequest(request) {
    return new Promise(function (resolve, reject) {
        request.onsuccess = function () {
            resolve(request.result);
        };

        request.onerror = function () {
            reject(request.error);
        };
    });
}

function promisifyRequestCall(obj, method, args) {
    var request;
    var p = new Promise(function (resolve, reject) {
        request = obj[method].apply(obj, args);
        promisifyRequest(request).then(resolve, reject);
    });

    p.request = request;
    return p;
}

function promisifyCursorRequestCall(obj, method, args) {
    var p = promisifyRequestCall(obj, method, args);
    return p.then(function (value) {
        if (!value) return;
        return new Cursor(value, p.request);
    });
}

function proxyProperties(ProxyClass, targetProp, properties) {
    properties.forEach(function (prop) {
        Object.defineProperty(ProxyClass.prototype, prop, {
            get: function get() {
                return this[targetProp][prop];
            },
            set: function set(val) {
                this[targetProp][prop] = val;
            }
        });
    });
}

function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function (prop) {
        if (!(prop in Constructor.prototype)) return;
        ProxyClass.prototype[prop] = function () {
            return promisifyRequestCall(this[targetProp], prop, arguments);
        };
    });
}

function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function (prop) {
        if (!(prop in Constructor.prototype)) return;
        ProxyClass.prototype[prop] = function () {
            return this[targetProp][prop].apply(this[targetProp], arguments);
        };
    });
}

function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function (prop) {
        if (!(prop in Constructor.prototype)) return;
        ProxyClass.prototype[prop] = function () {
            return promisifyCursorRequestCall(this[targetProp], prop, arguments);
        };
    });
}

function Index(index) {
    this._index = index;
}

function Cursor(cursor, request) {
    this._cursor = cursor;
    this._request = request;
}

function ObjectStore(store) {
    this._store = store;
}

ObjectStore.prototype.createIndex = function () {
    return new Index(this._store.createIndex.apply(this._store, arguments));
};

ObjectStore.prototype.index = function () {
    return new Index(this._store.index.apply(this._store, arguments));
};

function Transaction(idbTransaction) {
    this._tx = idbTransaction;
    this.complete = new Promise(function (resolve, reject) {
        idbTransaction.oncomplete = function () {
            resolve();
        };
        idbTransaction.onerror = function () {
            reject(idbTransaction.error);
        };
        idbTransaction.onabort = function () {
            reject(idbTransaction.error);
        };
    });
}

Transaction.prototype.objectStore = function () {
    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};

function UpgradeDB(db, oldVersion, transaction) {
    this._db = db;
    this.oldVersion = oldVersion;
    this.transaction = new Transaction(transaction);
}

UpgradeDB.prototype.createObjectStore = function () {
    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};

function DB$3(db) {
    this._db = db;
}

DB$3.prototype.transaction = function () {
    return new Transaction(this._db.transaction.apply(this._db, arguments));
};

var exp;

function checkPropertyNotSupportReason() {
    try {
        ['IDBIndex', 'IDBCursor', 'IDBObjectStore', 'IDBTransaction', 'IDBDatabase'].forEach(function (item) {
            if (window && !window[item]) {
                throw new Error(item);
            } else
                // 非window环境，比如service worker下
                if (!window && self && !self[item]) {
                    throw new Error(item);
                }
        });
        return '';
    } catch (e) {
        return e.message;
    }
}

// 为了使下面用到相关属性的代码在加载时不致报错
if (!checkPropertyNotSupportReason()) {
    proxyProperties(Index, '_index', ['name', 'keyPath', 'multiEntry', 'unique']);

    proxyRequestMethods(Index, '_index', IDBIndex, ['get', 'getKey', 'getAll', 'getAllKeys', 'count']);

    proxyCursorRequestMethods(Index, '_index', IDBIndex, ['openCursor', 'openKeyCursor']);

    proxyProperties(Cursor, '_cursor', ['direction', 'key', 'primaryKey', 'value']);

    proxyRequestMethods(Cursor, '_cursor', IDBCursor, ['update', 'delete']);

    // proxy 'next' methods
    ['advance', 'continue', 'continuePrimaryKey'].forEach(function (methodName) {
        if (!(methodName in IDBCursor.prototype)) return;
        Cursor.prototype[methodName] = function () {
            var cursor = this;
            var args = arguments;
            return Promise.resolve().then(function () {
                cursor._cursor[methodName].apply(cursor._cursor, args);
                return promisifyRequest(cursor._request).then(function (value) {
                    if (!value) return;
                    return new Cursor(value, cursor._request);
                });
            });
        };
    });

    proxyProperties(ObjectStore, '_store', ['name', 'keyPath', 'indexNames', 'autoIncrement']);

    proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, ['put', 'add', 'delete', 'clear', 'get', 'getAll', 'getKey', 'getAllKeys', 'count']);

    proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, ['openCursor', 'openKeyCursor']);

    proxyMethods(ObjectStore, '_store', IDBObjectStore, ['deleteIndex']);

    proxyProperties(Transaction, '_tx', ['objectStoreNames', 'mode']);

    proxyMethods(Transaction, '_tx', IDBTransaction, ['abort']);

    proxyProperties(UpgradeDB, '_db', ['name', 'version', 'objectStoreNames']);

    proxyMethods(UpgradeDB, '_db', IDBDatabase, ['deleteObjectStore', 'close']);

    proxyProperties(DB$3, '_db', ['name', 'version', 'objectStoreNames']);

    proxyMethods(DB$3, '_db', IDBDatabase, ['close']);

    // Add cursor iterators
    // TODO: remove this once browsers do the right thing with promises
    ['openCursor', 'openKeyCursor'].forEach(function (funcName) {
        [ObjectStore, Index].forEach(function (Constructor) {
            // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
            if (!(funcName in Constructor.prototype)) return;

            Constructor.prototype[funcName.replace('open', 'iterate')] = function () {
                var args = toArray$1(arguments);
                var callback = args[args.length - 1];
                var nativeObject = this._store || this._index;
                var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
                request.onsuccess = function () {
                    callback(request.result);
                };
            };
        });
    });

    // polyfill getAll
    [Index, ObjectStore].forEach(function (Constructor) {
        if (Constructor.prototype.getAll) return;
        Constructor.prototype.getAll = function (query, count) {
            var instance = this;
            var items = [];

            return new Promise(function (resolve) {
                instance.iterateCursor(query, function (cursor) {
                    if (!cursor) {
                        resolve(items);
                        return;
                    }
                    items.push(cursor.value);

                    if (count !== undefined && items.length == count) {
                        resolve(items);
                        return;
                    }
                    cursor.continue();
                });
            });
        };
    });
    exp = {
        open: function open(name, version, upgradeCallback) {
            var p = promisifyRequestCall(indexedDB, 'open', [name, version]);
            var request = p.request;
            if (request) {
                request.onupgradeneeded = function (event) {
                    if (upgradeCallback) {
                        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
                    }
                };
            }

            return p.then(function (db) {
                return new DB$3(db);
            });
        },
        delete: function _delete(name) {
            return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
        }
    };
} else {
    exp = {
        open: function open(name, version, upgradeCallback) {
            return Promise.reject(new Error('PROPERTY_NOT_SUPPORT'));
        },
        delete: function _delete(name) {
            return Promise.reject(new Error('PROPERTY_NOT_SUPPORT'));
        }
    };
}

var IDB = exp;

var reportToOwlCountQuota = 1; // 用于限制上报owl的次数，一次页面会话只报一次，无论成功还是失败，防止因为db失败导致的上报死循环

var OwlInstance = function OwlInstance() {
    if (window && window.Owl) {
        var OWL_CONFIG = {
            project: 'indexeddb',
            devMode: location && location.href.indexOf('dianping') === -1 && location.href.indexOf('meituan') === -1,
            resource: {
                sampleApi: 1,
                delay: 100
            }
        };
        return new window.Owl.OWL(OWL_CONFIG);
    } else {
        return '';
    }
};

var cat = function cat(code, msg, otherInfo) {
    var owl = OwlInstance();
    if (owl) {
        if (reportToOwlCountQuota > 0) {
            var catOb = {
                name: msg || '',
                statusCode: code,
                content: JSON.stringify(Object.assign({
                    'link': location.href,
                    'userAgent': window && window.navigator && window.navigator.userAgent
                }, otherInfo))
            };
            owl.addApi(catOb);
            reportToOwlCountQuota--;
        } else {}
    } else {
        // do nothing if current page has no owl
    }
};

var resultFormat = function resultFormat(code, msg) {
    return {
        code: code,
        msg: msg,
        data: {},
        setData: function setData(data) {
            return {
                code: code,
                msg: msg,
                data: data
            };
        }
    };
};

var RESULT = {
    'DB_NOT_SUPPORT': resultFormat(100, '该浏览器不支持IndexedDB'),
    'PARAM_INVALID': resultFormat(101, '无效的参数'),
    'PROPERTY_NOT_SUPPORT': resultFormat(102, 'DB方法、属性不受支持'),
    'SUCC': resultFormat(200, '成功'),
    'DB_NOT_FOUND': resultFormat(201, '找不到数据库'),
    'TABLE_NOT_FOUND': resultFormat(202, '找不到数据表'),
    'DB_OPEN_FAIL': resultFormat(203, '数据库打开失败'),
    'DB_ADD_ITEMS_FAIL': resultFormat(204, '数据库添加数据失败'),
    'DB_GET_ITEM_FAIL': resultFormat(205, '数据库获取数据失败'),
    'DB_GET_ITEMS_WITH_CURSOR_FAIL': resultFormat(206, '数据库使用游标获取数据失败'),
    'DB_DELETE_ITEMS_FAIL': resultFormat(207, '删除数据失败'),
    'DB_DELETE_FAIL': resultFormat(208, '删除数据库失败'),
    'ITEM_EXPIRED': resultFormat(301, '数据过期了'),
    'ITEM_NOT_FOUND': resultFormat(302, '找不到数据')
};

var IDB_MANAGER_DB_NAME = 'IDB_MANAGER_DB'; // 用于管理所有创建过的DB
var IDB_MANAGER_DB_STORE_NAME = 'IDB_MANAGER_STORE';
var IDB_MANAGER_DB_STORE_INDEX_NAME = 'dbName';
var UPDATETIME_KEYNAME = 'updateTime'; // 记录更新时间戳
var EXPIRETIME_KEYNAME = 'expireTime'; // 记录到期时间戳（毫秒计）；-1表示不过期
var DEFAULT_EXPIRE_SECONDS = 7 * 24 * 3600; // 记录默认保存7天
var debug$1 = false;

// 管理当前所有DB的建表数据
// TODO add DB administration
var _registerDBToManager = function _registerDBToManager(dbName, tableList) {
    return new Promise(function (resolve, reject) {
        IDB.open(IDB_MANAGER_DB_NAME, 1, function (upgradeDB) {
            try {
                upgradeDB.createObjectStore(IDB_MANAGER_DB_STORE_NAME, { keyPath: IDB_MANAGER_DB_STORE_INDEX_NAME });
            } catch (e) {
                reject(e);
            }
        }).then(function (db) {
            getItem(db, IDB_MANAGER_DB_STORE_NAME, dbName)
            // db已经注册过了
            .then(resolve).catch(function (e) {
                if (e.code === RESULT['ITEM_NOT_FOUND'].code) {
                    var item = {};
                    item[UPDATETIME_KEYNAME] = Date.now();
                    item[IDB_MANAGER_DB_STORE_INDEX_NAME] = dbName;
                    item['tableList'] = tableList;
                    item['version'] = 1; // TODO 后期有了version更新能力后需要修改
                    var trans = db.transaction(IDB_MANAGER_DB_STORE_NAME, 'readwrite'); // 建立transaction
                    var table = trans.objectStore(IDB_MANAGER_DB_STORE_NAME);
                    table.put(item).catch(reject);
                    trans.complete.then(resolve).catch(reject);
                } else {
                    reject(e);
                }
            });
        }).catch(reject);
    });
};

// TODO need db administration
var _cancelFromManager = function _cancelFromManager(dbName) {
    return new Promise(function (resolve, reject) {
        IDB.open(IDB_MANAGER_DB_NAME, 1, function (upgradeDB) {
            try {
                upgradeDB.createObjectStore(IDB_MANAGER_DB_STORE_NAME, { keyPath: IDB_MANAGER_DB_STORE_INDEX_NAME });
            } catch (e) {
                reject(e);
            }
        }).then(function (db) {
            var trans = db.transaction(IDB_MANAGER_DB_STORE_NAME, 'readwrite');
            var table = trans.objectStore(IDB_MANAGER_DB_STORE_NAME);
            table.delete(dbName).catch(reject);
            trans.complete.then(resolve).catch(reject);
        }).catch(reject);
    });
};
// TODO add DB administration
var _getDBFromManager = function _getDBFromManager(dbName) {
    return new Promise(function (resolve, reject) {
        IDB.open(IDB_MANAGER_DB_NAME, 1, function (upgradeDB) {
            // in case db manager was not created before
            try {
                upgradeDB.createObjectStore(IDB_MANAGER_DB_STORE_NAME, { keyPath: IDB_MANAGER_DB_STORE_INDEX_NAME });
            } catch (e) {
                reject(e);
            }
        }).then(function (db) {
            getItem(db, IDB_MANAGER_DB_STORE_NAME, dbName).then(function (result) {
                resolve(result.data.value); // {dbName, tableList}
            }).catch(function (e) {
                if (e.code === RESULT['ITEM_NOT_FOUND'].code) {
                    reject(RESULT['DB_NOT_FOUND'], dbName + ' is not found');
                } else {
                    reject(e);
                }
            });
        }).catch(reject);
    });
};

var _itemWrapper = function _itemWrapper(item, maxAgeInSeconds) {
    var defaultKV = {};
    var currentTime = Date.now();
    defaultKV[UPDATETIME_KEYNAME] = currentTime;
    if (maxAgeInSeconds > 0 && !isNaN(new Date(currentTime + parseInt(maxAgeInSeconds) * 1000).getTime())) {
        defaultKV[EXPIRETIME_KEYNAME] = currentTime + parseInt(maxAgeInSeconds) * 1000;
    } else {
        defaultKV[EXPIRETIME_KEYNAME] = -1;
    }
    return Object.assign({}, item, defaultKV);
};

var _promiseResultWrapper = function _promiseResultWrapper(action, result, e) {
    if (e) {
        var errJsonString = '';
        try {
            errJsonString = JSON.stringify(e);
        } catch (e) {
            // do nothing
        }
        result = result.setData({ detailErrMsg: e.msg || e.message || e.stack || errJsonString || e.toString() });
        if (result.code !== RESULT['DB_NOT_FOUND'].code && result.code !== RESULT['TABLE_NOT_FOUND'].code && result.code !== RESULT['ITEM_EXPIRED'].code && result.code !== RESULT['ITEM_NOT_FOUND'].code) {
            // 将DB的异常做cat上报
            cat(result.code, result.msg, result.data);
        }
    }
    debug$1 && console && console.log(result);
    action(result);
};

/**
 * list去重
 * @param list [name1, name2, name1,...]
 * @returns deduplicatedList [name1, name2, ...]
 */
var _deduplicateList = function _deduplicateList(list) {
    var deduplicatedList = list.reduce(function (accumulator, currentItem) {
        if (accumulator.indexOf(currentItem) < 0) {
            return accumulator.concat(currentItem);
        } else {
            return accumulator;
        }
    }, []);
    return deduplicatedList;
};

var _tableNameListInvalidationReason = function _tableNameListInvalidationReason(tableNameList, db) {
    for (var i = 0; i < tableNameList.length; i++) {
        var currentTableName = tableNameList[i];
        if (!currentTableName) {
            return 'Has invalid tableName';
        }
        if (db && !db.objectStoreNames.contains(currentTableName)) {
            return currentTableName + ' not found in db ' + db.name;
        }
    }
    return '';
};

var checkDBNotSupportReason$1 = function checkDBNotSupportReason() {
    try {
        ['indexedDB', 'IDBDatabase', 'IDBObjectStore', 'IDBTransaction', 'IDBIndex', 'IDBCursor', 'IDBKeyRange'].forEach(function (item) {
            if (window && !window[item]) {
                throw new Error(item);
            } else if (!window && self && !self[item]) {
                throw new Error(item);
            }
        });
        return '';
    } catch (e) {
        return e.message;
    }
};

var setDebugger$1 = function setDebugger() {
    console && console.log('------start db debug------');
    debug$1 = true;
};

/**
 * @param rangeOb {
 * indexName:xxx
 * onlyIndex:xx(optional)
 * lowerIndex:xx(optional)
 * upperIndex:xx(optional) 如果onlyIndex、lowerIndex和upperIndex都为空，则upperIndex兜底为''，将不会取到任何数据
 * lowerExclusive:boolean || false
 * upperExclusive:boolean || false
 * }
 */
var trans2DBKey = function trans2DBKey(rangeOb) {
    var onlyIndex = rangeOb.onlyIndex,
        lowerIndex = rangeOb.lowerIndex,
        upperIndex = rangeOb.upperIndex,
        lowerExclusive = rangeOb.lowerExclusive,
        upperExclusive = rangeOb.upperExclusive;

    if (onlyIndex || onlyIndex == 0) {
        return IDBKeyRange.only(onlyIndex);
    } else if ((lowerIndex || lowerIndex == 0) && (upperIndex || upperIndex == 0)) {
        return IDBKeyRange.bound(lowerIndex, upperIndex, Boolean(lowerExclusive), Boolean(upperExclusive));
    } else if (lowerIndex || lowerIndex == 0) {
        return IDBKeyRange.lowerBound(lowerIndex, Boolean(lowerExclusive));
    } else {
        return IDBKeyRange.upperBound(upperIndex || '', Boolean(upperExclusive));
    }
};

/**
 * create table if table does not exist
 * @param dbName
 * @param tableList [{tableName, primaryKey, indexList:[{indexName, unique}]}]
 * @returns resolve data {db}
 */
var createDB = function createDB(dbName, tableList, registered) {
    return new Promise(function (resolve, reject) {
        if (!dbName) {
            _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], 'dbName:' + dbName + ' invalid');
            return;
        }
        if (!(tableList instanceof Array)) {
            _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], 'tableList must be an array');
            return;
        }
        var tableNameListInvalidReason = _tableNameListInvalidationReason(tableList.map(function (table) {
            return table.tableName;
        }));
        if (tableNameListInvalidReason) {
            _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], tableNameListInvalidReason);
        } else if (tableList.length !== _deduplicateList(tableList.map(function (table) {
            return table.tableName;
        })).length) {
            _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], 'tableList has duplicated tableName');
        } else if (checkDBNotSupportReason$1()) {
            _promiseResultWrapper(reject, RESULT['DB_NOT_SUPPORT'], new Error(checkDBNotSupportReason$1()));
        } else {
            var _openDB = function _openDB() {
                // db version is always set 1 to avoid open old version when db version is higher. That will cause opening db fail.
                // TODO: version can be supported by db manager
                IDB.open(dbName, 1, function (upgradeDB) {
                    try {
                        tableList.forEach(function (table) {
                            var store = void 0;
                            if (typeof table.primaryKey === 'string' && table.primaryKey.trim()) {
                                store = upgradeDB.createObjectStore(table.tableName, { keyPath: table.primaryKey });
                                // 主键默认不建立索引，所以主动建立主键索引，主键唯一
                                store.createIndex(table.primaryKey, table.primaryKey, { unique: true });
                            } else {
                                store = upgradeDB.createObjectStore(table.tableName, { keyPath: 'id', autoIncrement: true });
                                store.createIndex('id', 'id', { unique: true });
                            }
                            table.indexList && table.indexList.forEach(function (index) {
                                if (index.indexName) {
                                    store.createIndex(index.indexName, index.indexName, { unique: Boolean(index.unique) });
                                }
                            });
                            // 默认对expireTime建立索引，方便后续删除操作
                            store.createIndex(EXPIRETIME_KEYNAME, EXPIRETIME_KEYNAME, { unique: false });
                        });
                    } catch (e) {
                        // 捕捉创建store时的同步错误，但此时该DB已经被open，需要delete
                        _promiseResultWrapper(reject, RESULT['DB_OPEN_FAIL'], e);
                        upgradeDB.close(); // 为了阻止发生同步错误时候db还被open成功，此时close connection可以让open的promise失败：DOMException: The connection was closed.
                        deleteDB$1(dbName);
                    }
                }).then(function (db) {
                    _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ db: db }));
                }).catch(function (e) {
                    _promiseResultWrapper(reject, RESULT['DB_OPEN_FAIL'], e);
                });
            };
            if (registered) {
                _openDB();
            } else {
                _registerDBToManager(dbName, tableList).then(_openDB).catch(function (e) {
                    _promiseResultWrapper(reject, RESULT['DB_OPEN_FAIL'], e);
                });
            }
        }
    });
};

/**
 * @param dbName
 * @returns resolve data {db}
 */
var openDB = function openDB(dbName) {
    return new Promise(function (resolve, reject) {
        if (!dbName) {
            _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], 'dbName:' + dbName + ' invalid');
        } else if (checkDBNotSupportReason$1()) {
            _promiseResultWrapper(reject, RESULT['DB_NOT_SUPPORT'], new Error(checkDBNotSupportReason$1()));
        } else {
            _getDBFromManager(dbName).then(function (dbOb) {
                // dbOb: {dbName, tableList}
                // 防止业务db不存在，需要获取注册过的db的表与索引结构后再open
                createDB(dbOb.dbName, dbOb.tableList, true).then(resolve).catch(function (e) {
                    _promiseResultWrapper(reject, RESULT['DB_OPEN_FAIL'], e);
                });
            }).catch(function (e) {
                if (e.code === RESULT['DB_NOT_FOUND'].code) {
                    _promiseResultWrapper(reject, RESULT['DB_NOT_FOUND'], e);
                } else {
                    _promiseResultWrapper(reject, RESULT['DB_OPEN_FAIL'], e);
                }
            });
        }
    });
};

/**
 * 添加数据，事务包裹，可在多个store中添加数据，若其中一个添加失败，则所有添加的数据都被回滚
 * @param db
 * @param itemList [{tableName, item, maxAgeInSeconds}...]
 * @returns resolve && reject Result
 */
var addItems = function addItems(db, itemList) {
    return new Promise(function (resolve, reject) {
        try {
            if (!(itemList instanceof Array)) {
                _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], 'itemList must be an array');
                return;
            }
            var dedupTableNameList = _deduplicateList(itemList.map(function (item) {
                return item.tableName;
            }));
            var hasInvalidTableNameReason = _tableNameListInvalidationReason(dedupTableNameList, db);
            if (hasInvalidTableNameReason) {
                _promiseResultWrapper(reject, RESULT['PARAM_INVALID'], hasInvalidTableNameReason);
                return;
            }
            var trans = db.transaction(dedupTableNameList, 'readwrite'); // 建立transaction
            itemList.forEach(function (itemInfo) {
                var table = trans.objectStore(itemInfo.tableName);
                var wrappedItem = _itemWrapper(itemInfo.item, itemInfo.maxAgeInSeconds || DEFAULT_EXPIRE_SECONDS);
                table.put(wrappedItem).catch(function (e) {
                    // 如果item没有包含primaryKey等错误，则会在这抛错并catch，直接reject了
                    _promiseResultWrapper(reject, RESULT['DB_ADD_ITEMS_FAIL'], e);
                    try {
                        // 使此次trans内的操作全部回滚，其余的put操作都会抛错再次走进这里，导致abort方法抛出trans已经关闭的错误，所以需要catch
                        trans.abort();
                    } catch (e) {
                        // do nothing, only catch
                    }
                });
            });
            trans.complete.then(function () {
                // 记录一次成功的save
                cat(RESULT['SUCC'].code, RESULT['SUCC'].msg);
                _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ detail: 'addItems succ' }));
            }).catch(function (e) {
                _promiseResultWrapper(reject, RESULT['DB_ADD_ITEMS_FAIL'], e);
            });
        } catch (e) {
            _promiseResultWrapper(reject, RESULT['DB_ADD_ITEMS_FAIL'], e);
        }
    });
};

/**
 * @returns resolve data {value}
 */
var getItem = function getItem(db, tableName, primaryKeyValue) {
    return new Promise(function (resolve, reject) {
        try {
            if (db.objectStoreNames.contains(tableName)) {
                var trans = db.transaction(tableName, 'readonly');
                var table = trans.objectStore(tableName);
                table.get(primaryKeyValue).then(function (itemValue) {
                    if (!itemValue) {
                        _promiseResultWrapper(reject, RESULT['ITEM_NOT_FOUND']);
                    } else if (itemValue[EXPIRETIME_KEYNAME] > 0 && itemValue[EXPIRETIME_KEYNAME] < Date.now()) {
                        _promiseResultWrapper(reject, RESULT['ITEM_EXPIRED']);
                    } else {
                        _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ value: itemValue }));
                    }
                }).catch(function (e) {
                    _promiseResultWrapper(reject, RESULT['DB_GET_ITEM_FAIL'], e);
                });
            } else {
                _promiseResultWrapper(reject, RESULT['TABLE_NOT_FOUND']);
            }
        } catch (e) {
            _promiseResultWrapper(reject, RESULT['DB_GET_ITEM_FAIL'], e);
        }
    });
};

/**
 * 按照key范围获取数据
 * @param db
 * @param tableName
 * @param rangeOb:{
    * indexName:xxx
    * onlyIndex:xx(optional)
    * lowerIndex:xx(optional)
    * upperIndex:xx(optional)
    * lowerExclusive:boolean || false
    * upperExclusive:boolean || false
 * }
 * @returns resolve data {values: []}
 */
var getBetweenRange = function getBetweenRange(db, tableName, rangeOb) {
    return new Promise(function (resolve, reject) {
        try {
            if (!db.objectStoreNames.contains(tableName)) {
                _promiseResultWrapper(reject, RESULT['TABLE_NOT_FOUND']);
                return;
            }
            var trans = db.transaction(tableName, 'readonly');
            var table = trans.objectStore(tableName);
            // 全捞
            if (!rangeOb) {
                table.getAll().then(function (allValue) {
                    _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ values: allValue || [] }));
                }).catch(function (e) {
                    _promiseResultWrapper(reject, RESULT['DB_GET_ITEM_FAIL'], e);
                });
            } else {
                var values = [];
                var cursorIter = function cursorIter(cursor) {
                    if (!cursor) {
                        _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ values: values }));
                    } else {
                        values.push(cursor.value);
                        cursor.continue().then(cursorIter).catch(function (e) {
                            _promiseResultWrapper(reject, RESULT['DB_GET_ITEMS_WITH_CURSOR_FAIL'], e);
                        });
                    }
                };
                var index = table.index(rangeOb.indexName);
                if (typeof index.openCursor !== 'function') {
                    _promiseResultWrapper(reject, RESULT['PROPERTY_NOT_SUPPORT'], 'index.openCursor is not supported');
                } else {
                    index.openCursor(trans2DBKey(rangeOb)).then(cursorIter).catch(function (e) {
                        _promiseResultWrapper(reject, RESULT['DB_GET_ITEMS_WITH_CURSOR_FAIL'], e);
                    });
                }
            }
        } catch (e) {
            _promiseResultWrapper(reject, RESULT['DB_GET_ITEMS_WITH_CURSOR_FAIL'], e);
        }
    });
};
var deleteExpiredItems = function deleteExpiredItems(db, tableNameList) {
    function deleteWithRecursion(tableList, resolve, reject) {
        if (tableList.length > 0) {
            try {
                var tableName = tableList[0]; // get first tableName from tableList
                var trans = db.transaction(tableName, 'readwrite');
                var table = trans.objectStore(tableName);
                var index = table.index(EXPIRETIME_KEYNAME);
                var cursorIter = function cursorIter(cursor) {
                    if (cursor) {
                        table.delete(cursor.primaryKey).catch(function (e) {
                            _promiseResultWrapper(reject, RESULT['DB_DELETE_ITEMS_FAIL'], e);
                        });
                        cursor.continue().then(cursorIter).catch(function (e) {
                            _promiseResultWrapper(reject, RESULT['DB_DELETE_ITEMS_FAIL'], e);
                        });
                    } else {
                        // end cursorIter，back to table recursion
                        deleteWithRecursion(tableList.slice(1), resolve, reject);
                    }
                };
                // >=0 <=now的都算过期，-1表示永久 所以不能删
                if (typeof index.openCursor !== 'function') {
                    _promiseResultWrapper(reject, RESULT['PROPERTY_NOT_SUPPORT'], 'index.openCursor is not supported');
                } else {
                    index.openCursor(trans2DBKey({ indexName: EXPIRETIME_KEYNAME, lowerIndex: 0, upperIndex: Date.now(), lowerExclusive: false, upperExclusive: false })).then(cursorIter).catch(function (e) {
                        _promiseResultWrapper(reject, RESULT['DB_DELETE_ITEMS_FAIL'], e);
                    });
                }
            } catch (e) {
                // catch cursor相关的同步错误
                _promiseResultWrapper(reject, RESULT['DB_DELETE_ITEMS_FAIL'], e);
            }
        } else {
            resolve();
        }
    }
    return new Promise(function (resolve, reject) {
        if (!(tableNameList instanceof Array)) {
            resolve();
        } else {
            var dedupTableNameList = _deduplicateList(tableNameList);
            var hasInvalidTableNameReason = _tableNameListInvalidationReason(dedupTableNameList, db);
            if (hasInvalidTableNameReason) {
                resolve();
            } else {
                deleteWithRecursion(dedupTableNameList, resolve, reject);
            }
        }
    });
};

var deleteDB$1 = function deleteDB(dbName) {
    return new Promise(function (resolve, reject) {
        _cancelFromManager(dbName).then(function () {
            IDB.delete(dbName).then(function () {
                _promiseResultWrapper(resolve, RESULT['SUCC'].setData({ detail: 'deleteDB succ' }));
            }).catch(function (e) {
                _promiseResultWrapper(reject, RESULT['DB_DELETE_FAIL'], e);
            });
        }).catch(function (e) {
            _promiseResultWrapper(reject, RESULT['DB_DELETE_FAIL'], e);
        });
    });
};

var DB$1 = {
    checkDBNotSupportReason: checkDBNotSupportReason$1,
    setDebugger: setDebugger$1,
    createDB: createDB,
    openDB: openDB,
    addItems: addItems,
    getItem: getItem,
    getBetweenRange: getBetweenRange,
    deleteExpiredItems: deleteExpiredItems,
    deleteDB: deleteDB$1
};

var SINGLE_DATA_DB_NAME = 'SINGLE_DATA_DB';
var SINGLE_DATA_STORE_NAME = 'SINGLE_DATA_STORE';
var SINGLE_DATA_PRIMARY_KEYNAME = 'keyName';
var SINGLE_DATA_VALUENAME = 'value';

var setDebugger = function setDebugger() {
    DB$1.setDebugger();
};

var checkDBNotSupportReason = function checkDBNotSupportReason() {
    return DB$1.checkDBNotSupportReason();
};

// 单条数据存储 resolve空；reject Result
var setKV = function setKV(keyName, value, maxAgeInSeconds) {
    return new Promise(function (resolve, reject) {
        if (keyName) {
            DB$1.createDB(SINGLE_DATA_DB_NAME, [{ tableName: SINGLE_DATA_STORE_NAME, primaryKey: SINGLE_DATA_PRIMARY_KEYNAME, indexList: [] }]).then(function (result) {
                var database = result.data.db;
                var item = {};
                item[SINGLE_DATA_PRIMARY_KEYNAME] = keyName;
                item[SINGLE_DATA_VALUENAME] = value;
                // 先删 再加新的
                DB$1.deleteExpiredItems(database, [SINGLE_DATA_STORE_NAME]).then(function () {
                    DB$1.addItems(database, [{ tableName: SINGLE_DATA_STORE_NAME, item: item, maxAgeInSeconds: maxAgeInSeconds }]).then(function () {
                        resolve();
                    }).catch(reject);
                }).catch(reject);
            }).catch(reject);
        } else {
            reject(RESULT['PARAM_INVALID'].setData({ detailErrMsg: 'keyName is invalid' }));
        }
    });
};

// 单条数据获取 resolve{addTime, expireTime, keyName, value}；reject Result
var getKV = function getKV(keyName) {
    return new Promise(function (resolve, reject) {
        DB$1.openDB(SINGLE_DATA_DB_NAME).then(function (result) {
            var database = result.data.db;
            DB$1.getItem(database, SINGLE_DATA_STORE_NAME, keyName).then(function (result) {
                resolve(result.data.value);
            }).catch(reject);
        }).catch(reject);
    });
};

var deleteDB = function deleteDB(dbName) {
    return new Promise(function (resolve, reject) {
        DB$1.deleteDB(dbName).then(function () {
            resolve();
        }).catch(reject);
    });
};

/**
 * 从db库中获取数据
 * @param dbName 库名
 * @param tableName 表名
 * @param primaryKeyValue 索引值
 * @return resolve{addTime, expireTime, ...}；reject Result
 */
var getItemFromDB = function getItemFromDB(dbName, tableName, primaryKeyValue) {
    return new Promise(function (resolve, reject) {
        DB$1.openDB(dbName).then(function (result) {
            DB$1.getItem(result.data.db, tableName, primaryKeyValue).then(function (result) {
                resolve(result.data.value);
            }).catch(reject);
        }).catch(reject);
    });
};

/**
 * 从db库中获取数据
 * @param dbName 库名
 * @param tableName 表名
 * @param rangeOb:{
    * indexName:xxx
    * onlyIndex:xx(optional)
    * lowerIndex:xx(optional)
    * upperIndex:xx(optional)
    * lowerExclusive:boolean || false
    * upperExclusive:boolean || false
 * } 索引值范围，optional，不配则全捞
 * @return resolve[]；reject Result
 */
var getBetweenRangeFromDB = function getBetweenRangeFromDB(dbName, tableName, rangeOb) {
    return new Promise(function (resolve, reject) {
        DB$1.openDB(dbName).then(function (result) {
            DB$1.getBetweenRange(result.data.db, tableName, rangeOb).then(function (result) {
                resolve(result.data.values);
            }).catch(reject);
        }).catch(reject);
    });
};

var CustomDB = function () {
    // tableList:[{tableName, primaryKey, indexList:[{indexName, unique}]}...]
    function CustomDB(dbConfig) {
        classCallCheck(this, CustomDB);

        if (!dbConfig) {
            throw new Error('CustomDB need dbConfig!');
        }
        if (!dbConfig.dbName) {
            throw new Error('CustomDB dbName invalid!');
        }
        if (!(dbConfig.tableList instanceof Array)) {
            throw new Error('CustomDB tableList must be an Array');
        }
        this.dbName = dbConfig.dbName;
        this.tableList = dbConfig.tableList;
    }
    // itemList:[{tableName, item, maxAgeInSeconds}...]


    createClass(CustomDB, [{
        key: 'addItems',
        value: function addItems(itemList) {
            var _this = this;

            return new Promise(function (resolve, reject) {
                if (!(itemList instanceof Array)) {
                    reject(RESULT['PARAM_INVALID'].setData({ detailErrMsg: 'addItems input must be an array' }));
                } else {
                    DB$1.createDB(_this.dbName, _this.tableList).then(function (result) {
                        var database = result.data.db;
                        // 先删过期的 再添加新的
                        DB$1.deleteExpiredItems(database, itemList.map(function (item) {
                            return item.tableName;
                        })).then(function () {
                            DB$1.addItems(database, itemList).then(function () {
                                resolve();
                            }).catch(reject);
                        }).catch(reject);
                    }).catch(reject);
                }
            });
        }
        // resolve{addTime, expireTime, ...}；reject Result

    }, {
        key: 'getItem',
        value: function getItem(tableName, primaryKeyValue) {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                getItemFromDB(_this2.dbName, tableName, primaryKeyValue).then(resolve).catch(reject);
            });
        }
        // resolve[]；reject Result

    }, {
        key: 'getBetweenRange',
        value: function getBetweenRange(tableName, rangeOb) {
            var _this3 = this;

            return new Promise(function (resolve, reject) {
                getBetweenRangeFromDB(_this3.dbName, tableName, rangeOb).then(resolve).catch(reject);
            });
        }
    }]);
    return CustomDB;
}();

var IndexedDB = {
    setDebugger: setDebugger,
    checkDBNotSupportReason: checkDBNotSupportReason,
    getKV: getKV,
    setKV: setKV,
    deleteDB: deleteDB,
    getItemFromDB: getItemFromDB,
    getBetweenRangeFromDB: getBetweenRangeFromDB,
    CustomDB: CustomDB
};

var IDBStorage = function () {
  function IDBStorage(_ref) {
    var project = _ref.project,
        version = _ref.version;
    classCallCheck(this, IDBStorage);

    this.type = 'IDBCache';
    this.prefix = 'Thunder:cache:' + project;
    this.project = project;
    this.state = {
      cacheMap: {}
    };
    this.db = IndexedDB;
  }

  createClass(IDBStorage, [{
    key: '_getCacheName',
    value: function _getCacheName(name) {
      return this.prefix + '~' + name;
    }
  }, {
    key: 'add',
    value: function add(payload) {
      var name = payload.name;
      return this.db.setKV(this._getCacheName(name), payload, payload.cacheAge || 3600 * 24 * 365);
    }
  }, {
    key: 'get',
    value: function get$$1(name) {
      return this.db.getKV(this._getCacheName(name)).then(function (res) {
        return res.value;
      }).catch(function (e) {
        // ignore
        console.error(e);
      });
    }
  }, {
    key: 'saveChunksMap',
    value: function saveChunksMap() {}
  }, {
    key: 'remove',
    value: function remove(key) {
      // try remove
      return this.db.setKV(this._getCacheName(key), null, 1);
    }
  }, {
    key: 'clear',
    value: function clear(key, value) {
      // indexedDB.deleteDatabase(this.name)
    }
  }]);
  return IDBStorage;
}();

var Store = (function (thunder) {
  thunder.store = new IDBStorage({
    project: thunder.starkAppKey || thunder.state.project,
    version: thunder.version
  });
});

var CheckInBrowser = typeof window !== 'undefined';
var SupportPerformance = CheckInBrowser && 'performance' in window && 'now' in performance;

function timeNow$1() {
  if (SupportPerformance) return Math.floor(performance.now());
  return Date.now();
}

var DEFAULT_ADDRESS = 'https://jarvas-static.meituan.net/diff/';
var DEFAULT_FALLBACK = '//jarvas-static.meituan.net/file/PROJECT_NAME?filePath=';

var STARK_DIFF_STATUS = {
  PATCH: 2,
  FULL: 1,
  FAILED: 0
};
var STARK_DIFF_CODE = {
  CLIENT_PATCH_ERROR: 416,
  CHECKSUM_FAILED: 409,
  UNKNOWN_ERROR: 400,
  LOCAL_VERSION_NOT_FOUND: 205
};

function StarkError(message, code, result) {
  this.message = message;
  this.statusCode = code;
  this.result = result || {};
}

StarkError.prototype = new Error();
StarkError.prototype.constructor = StarkError;

/**
* recoverMin
* @param {string} source         LS中的缓存源文件
* @param {string} patchContent   Stark服务器返回的patch文件
* @return {Object} content: 新文件内容, fullLength全量大小, patchLength补丁大小
*/
function recoverMin() {
  var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var patchContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var units = patchContent.split('\t');
  var content = source;
  var pos = 0;

  var start = timeNow$1();

  for (var i = 0; i < units.length; i++) {
    var command = units[i][0];
    if (command === '=') {
      pos += parseInt(units[i].slice(1), 10);
    } else if (command === '-') {
      var length = parseInt(units[i].slice(1), 10);
      content = content.slice(0, pos) + content.slice(pos + length);
    } else if (command === '+') {
      var newPartial = decodeURI(units[i].slice(1));
      content = content.slice(0, pos) + newPartial + content.slice(pos);
      pos += newPartial.length;
    } else {
      throw new StarkError('Broken patch found', STARK_DIFF_CODE.CLIENT_PATCH_ERROR);
    }
  }

  return {
    content: content,
    fullLength: content.length,
    patchLength: patchContent.length,
    recoverCost: timeNow$1() - start
  };
}

function handleResponse(responseText, source) {
  var patchJson = JSON.parse(responseText);
  var result = void 0;

  if (patchJson.status === STARK_DIFF_STATUS.FAILED) {
    throw new StarkError('Stark service down', patchJson.code);
  }
  if (patchJson.status === STARK_DIFF_STATUS.FULL) {
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: patchJson.content,
      fullLength: patchJson.content.length,
      patchLength: patchJson.content.length,
      checksum: patchJson.newFileChecksum
    };
  }
  if (patchJson.status === STARK_DIFF_STATUS.PATCH) {
    var recoverResult = recoverMin(source, patchJson.content);
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: recoverResult.content,
      fullLength: recoverResult.fullLength,
      patchLength: recoverResult.patchLength,
      checksum: patchJson.newFileChecksum
    };
  }

  return result;
}

function genStarkLink(chunkName, localChunk, remoteChunk) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var address = options.address,
      projectName = options.projectName;

  var realAddress = address || DEFAULT_ADDRESS;

  if (!localChunk || !localChunk.hash) {
    return;
  }

  var oldFilePath = localChunk.filename;
  var newFilePath = remoteChunk.filename;

  var oldFilePathParam = encodeURIComponent(oldFilePath);
  var newFilePathParam = encodeURIComponent(newFilePath);

  return '' + realAddress + projectName + '?oldFilePath=' + oldFilePathParam + '&newFilePath=' + newFilePathParam;
}

var StarkUpdatePlugin = function () {
  function StarkUpdatePlugin(chunkName, _ref, options, helpers) {
    var localChunk = _ref.localChunk,
        remoteChunk = _ref.remoteChunk;
    classCallCheck(this, StarkUpdatePlugin);

    this.chunkName = chunkName;
    this.localChunk = localChunk || {};
    this.remoteChunk = remoteChunk;
    this.options = options;
    this.helpers = helpers;
  }

  createClass(StarkUpdatePlugin, [{
    key: 'report',
    value: function report(_ref2, result) {
      var status = _ref2.status,
          statusCode = _ref2.statusCode,
          loadCost = _ref2.loadCost;

      var chunkName = this.chunkName;
      var localChunk = this.localChunk;
      var remoteHash = this.remoteChunk.hash || this.remoteChunk.filename;

      this.helpers.logger.markOnce('stark:' + chunkName, {
        channel: 'lx',
        appKey: this.options.projectName, // 项目key,即管理系统生成的项目appkey
        fileName: chunkName, // 文件名字
        currentVersion: localChunk.hash, // 当前资源版本
        diffVersion: remoteHash, // 需要diff的版本
        saveSize: Math.max(result.fullLength - result.patchLength, 0), // diff节省的流量
        diffState: status,
        diffDetailState: statusCode,
        patchLength: result.patchLength,
        fullLength: result.fullLength,
        recoverCost: result.recoverCost,
        loadCost: loadCost, // 补丁请求时间
        checksum: result.checksum
      }, false);
    }
  }, {
    key: 'getDiff',
    value: function getDiff() {
      var _this = this;

      var chunkName = this.chunkName;
      var localChunk = this.localChunk;
      var remoteHash = this.remoteChunk.hash;
      var link = genStarkLink(chunkName, this.localChunk, this.remoteChunk, this.options);

      if (!localChunk || !localChunk.filename || !localChunk.content) return this.helpers.Promise.resolve();
      var start = timeNow$1();
      return this.helpers.request(link).then(function (responseText) {
        var result = handleResponse(responseText, localChunk.content);

        var status = result.status,
            statusCode = result.statusCode,
            content = result.content;


        _this.report({
          status: status,
          statusCode: statusCode,
          loadCost: timeNow$1() - start
        }, result);

        return content;
      }).then(function (content) {
        return {
          name: chunkName,
          content: content,
          hash: remoteHash,
          from: 'diff'
        };
      }, function (err) {
        _this.helpers.debug('error', 'getDiff failed', err);
        var statusCode = void 0;
        if (!localChunk.hash) {
          statusCode = STARK_DIFF_CODE.LOCAL_VERSION_NOT_FOUND;
        } else {
          statusCode = err.statusCode || STARK_DIFF_CODE.UNKNOWN_ERROR;
        }

        var result = err && err.result || {};

        _this.report({
          status: STARK_DIFF_STATUS.FAILED,
          statusCode: statusCode
        }, result);

        return _this.helpers.Promise.resolve();
      });
    }
  }]);
  return StarkUpdatePlugin;
}();

function StarkUpdate(chunkName, chunkData, thunder, helpers) {
  if (!thunder.state.StarkOptions) return helpers.Promise.resolve();
  var _thunder$state$StarkO = thunder.state.StarkOptions,
      projectName = _thunder$state$StarkO.projectName,
      fallback = _thunder$state$StarkO.fallback;

  var realFallback = fallback || DEFAULT_FALLBACK.replace('PROJECT_NAME', projectName);

  thunder.set({
    fallbackCDN: realFallback
  });
  var starkUpdator = new StarkUpdatePlugin(chunkName, chunkData, thunder.state.StarkOptions, helpers);
  return starkUpdator.getDiff();
}

function install(Thunder) {
  Thunder.prototype._updateAdapter = StarkUpdate;
}

var Emitter = function () {
  function Emitter() {
    classCallCheck(this, Emitter);

    this._listeners = {};
  }

  createClass(Emitter, [{
    key: '$on',
    value: function $on(type, fn, ctx) {
      ctx = ctx || null;
      if (!this._listeners[type]) this._listeners[type] = [];
      this._listeners[type].push({
        fn: fn,
        ctx: ctx
      });
      return this._listeners[type].length - 1;
    }
  }, {
    key: '$once',
    value: function $once(type, fn, ctx) {
      ctx = ctx || null;
      var func = function func() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        fn.apply(ctx, args);
        this.$off(type, func);
      };
      this.$on(type, func, this);
    }
  }, {
    key: '$off',
    value: function $off(type, fn) {
      var _this = this;

      if (!this._listeners[type] || !this._listeners[type].length) return;
      if (!fn) {
        this._listeners[type].map(function (ctx) {
          return ctx = null;
        });
        this._listeners[type].length = 0;
      }
      if (typeof fn === 'function') {
        this._listeners[type].map(function (ctx, i) {
          if (ctx.fn === fn) {
            _this._listeners[type].splice(i, 1);
            ctx = null;
          }
        });
      }
      // if (typeof cb === 'number') {
      //   this._listeners[type].splice(cb, 1)
      // }
    }
  }, {
    key: '$emit',
    value: function $emit() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (!args.length) return;
      var type = args[0];
      args.shift();
      if (this._listeners[type] && this._listeners[type].length) {
        this._listeners[type].map(function (item) {
          item.fn.apply(item.ctx, args);
        });
      }
    }
  }]);
  return Emitter;
}();

// getRegistrations : chrome 45
// onmessage : chrome 40
var SUPPORT_SERVICE_WORKER = Boolean(isBrowser && 'serviceWorker' in navigator && 'onmessage' in navigator.serviceWorker);
var SUPPORT_CACHE = isBrowser && 'caches' in window;
var SUPPORT_MESSAGE_CHANNEL = isBrowser && 'MessageChannel' in window;
// localhost
// [::1] is the IPv6 localhost address.
// 127.0.0.1/8 is considered localhost for IPv4.
var IN_LOCALHOST = Boolean(isBrowser && (window.location.hostname === 'localhost' || window.location.hostname === '[::1]' || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)));
var IN_HTTPS = Boolean(isBrowser && window.location.protocol === 'https:');
var SW_EVENT_PREFIX_REG = /^thunder:sw-event:/i;
var THUNDER_CACHE_NAME_PRE = /\$\$\$thunder-serviceworker/;

var ServiceWorkerManager = function (_Emitter) {
  inherits(ServiceWorkerManager, _Emitter);

  function ServiceWorkerManager(state, helpers) {
    classCallCheck(this, ServiceWorkerManager);

    var _this = possibleConstructorReturn(this, (ServiceWorkerManager.__proto__ || Object.getPrototypeOf(ServiceWorkerManager)).call(this));

    _this.state = state;
    _this.options = state.serviceWorker;
    _this.serviceWorker = null;
    _this.logger = helpers.logger;
    _this.cache = _this.initCache();
    _this.ready = _this._ready();
    return _this;
  }

  createClass(ServiceWorkerManager, [{
    key: 'isSupport',
    value: function isSupport() {
      return ServiceWorkerManager.isSupport();
    }
  }, {
    key: '_ready',
    value: function _ready() {
      var _this2 = this;

      if (!ServiceWorkerManager.isSupport()) {
        // return Promise.reject(new Error('current env not support service-worker'))
        return Promise.resolve();
      }
      if (!this.options) {
        ServiceWorkerManager.unregister();
        // return Promise.reject(new Error('did\'t provide serviceWorker options'))
        return Promise.resolve();
      }
      navigator.serviceWorker.onmessage = this.onMessage.bind(this);
      return this._register().then(function (sw) {
        _this2.serviceWorker = sw;
        _this2.sendMessage({
          command: 'update:ua',
          userAgent: window.navigator.userAgent
        });
        _this2.report();
        return sw;
      });
    }
  }, {
    key: '_register',
    value: function _register() {
      return navigator.serviceWorker.register(this.options.path + '?v=' + this.state.compilation.hash, {
        scope: this.options.scope
      }).then(function (reg) {
        // installing
        // waiting
        // active
        if (reg.active) return reg.active;
        return new Promise(function (resolve, reject) {
          reg.addEventListener('updatefound', function () {
            var newWorker = reg.installing;

            newWorker.addEventListener('statechange', function () {
              if (newWorker.state === 'activated') {
                resolve(newWorker);
              }
            });
          });
        });
      });
    }
  }, {
    key: 'report',
    value: function report() {
      var _this3 = this;

      this.sendMessage({ command: 'log' }).then(function (res) {
        if (!res.data && !(res.data instanceof Array)) return;
        var logs = res.data;
        logs.forEach(function (log) {
          _this3.logger.markOnce('sw:cachedFetch', _extends({
            channel: 'lx',
            reason: 'swCache'
          }, log.data, {
            url: log.key
          }));
        });
      }).catch(function (e) {
        _this3.logger.markOnce('swInitError', {
          channel: 'lx',
          reason: 'swInitError',
          message: e && e.message,
          stack: e & e.toString()
        });
        debug('warn', e);
      });
    }
  }, {
    key: 'initCache',
    value: function initCache() {
      var _this4 = this;

      return {
        keys: function keys$$1() {
          return _this4.sendMessage({ command: 'cache:keys' });
        },
        clear: function clear() {
          return _this4.sendMessage({ command: 'cache:clear' });
        },
        add: function add(url) {
          return _this4.sendMessage({ command: 'cache:add', url: url });
        },
        delete: function _delete(url) {
          return _this4.sendMessage({ command: 'cache:delete', url: url });
        }
      };
    }
  }, {
    key: 'sendMessage',
    value: function sendMessage(message) {
      var _this5 = this;

      return this.ready.then(function () {
        return new Promise(function (resolve, reject) {
          if (!_this5.serviceWorker) return reject(new Error('service-worker not ready'));
          if (!ServiceWorkerManager.env.SUPPORT_MESSAGE_CHANNEL) return reject(new Error('unsupport MessageChannel'));
          var channel = new MessageChannel();
          channel.port1.onmessage = function (event) {
            if (event.data.error) {
              reject(event.data.error);
            } else {
              resolve(event.data);
            }
          };
          _this5.serviceWorker.postMessage(message, [channel.port2]);
        });
      });
    }
  }, {
    key: 'onMessage',
    value: function onMessage(e) {
      if (!e.data && e.data instanceof Object) return;
      var data = e.data;
      var type = data.type || '';
      if (ServiceWorkerManager.env.SW_EVENT_PREFIX_REG.test(type)) {
        var eventType = type.replace(ServiceWorkerManager.env.SW_EVENT_PREFIX_REG, '');
        this.$emit(eventType, data);
      }
    }
  }, {
    key: 'active',
    get: function get$$1() {
      if (!ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER) return false;
      if (!navigator.serviceWorker.controller) return false;
      return navigator.serviceWorker.controller.state === 'activated';
    }
  }], [{
    key: 'isSupport',
    value: function isSupport() {
      return ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER && (ServiceWorkerManager.env.IN_HTTPS || ServiceWorkerManager.env.IN_LOCALHOST);
    }
  }, {
    key: 'unregister',
    value: function unregister() {
      /* Secure Origin issue
          * Secure origins
          * (https, *, *)
          * (wss, *, *)
          * (*, localhost, *)
          * (*, 127/8, *)
          * (*, ::1/128, *)
          * (file, *, —)
          * (chrome-extension, *, —)
          */
      if (ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER && ServiceWorkerManager.env.SUPPORT_CACHE && caches.keys) {
        caches.keys().then(function (keys$$1) {
          keys$$1.forEach(function (key) {
            if (ServiceWorkerManager.env.THUNDER_CACHE_NAME_PRE.test(key)) {
              caches.delete(key);
              debug('cache cleard');
            }
          });
        }).catch(function (err) {
          debug('error', 'unregister', err);
        });
      }
      if (ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER) {
        // chrome 40, single
        if (navigator.serviceWorker.getRegistration) {
          navigator.serviceWorker.getRegistration().then(function (registration) {
            if (!registration) return;
            registration.unregister();
            debug('sw unregisted');
          }).catch(function (err) {
            debug('error', 'unregister', err);
          });
        }
        if (navigator.serviceWorker.getRegistrations) {
          navigator.serviceWorker.getRegistrations().then(function (registrations) {
            registrations.forEach(function (registration) {
              registration.unregister();
            });
            debug('sw unregisted');
          }).catch(function (err) {
            debug('error', 'unregister', err);
          });
        }
      }
    }
  }]);
  return ServiceWorkerManager;
}(Emitter);

ServiceWorkerManager.env = {
  THUNDER_CACHE_NAME_PRE: THUNDER_CACHE_NAME_PRE,
  SW_EVENT_PREFIX_REG: SW_EVENT_PREFIX_REG,
  IN_HTTPS: IN_HTTPS,
  IN_LOCALHOST: IN_LOCALHOST,
  SUPPORT_MESSAGE_CHANNEL: SUPPORT_MESSAGE_CHANNEL,
  SUPPORT_CACHE: SUPPORT_CACHE,
  SUPPORT_SERVICE_WORKER: SUPPORT_SERVICE_WORKER
};

var serviceWorkerPlugin = (function (thunder) {
  thunder.serviceWorkerManager = new ServiceWorkerManager(thunder.state, {
    logger: thunder.logger
  });
});

// 暴露 Promise polyfill
window.Promise = Promise$1;

Thunder$1.use(Logger$1).use(Store).use(serviceWorkerPlugin).use(function () {
  return install(Thunder$1);
});

return Thunder$1;

})));
