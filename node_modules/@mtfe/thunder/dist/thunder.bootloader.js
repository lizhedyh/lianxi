/*!
 * Thunder.js v2.3.7
 * (c) 2019-07-02 14:28:13 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Thunder = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined';

// inspired by https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
var supportLS = function (storage) {
  if (!storage) return false;
  try {
    var key = '__LS_SUPPORT_TEST_KEY__';
    storage.setItem(key, key);
    storage.removeItem(key, key);
    return true;
  } catch (e) {
    return false;
  }
}(window.localStorage);

var isDEBUG = isBrowser && 'DEBUG_THUNDER' in window && window.DEBUG_THUNDER;
var supportFetch = isBrowser && 'fetch' in window;
var isUnitTest = isBrowser && 'UNIT_TEST_THUNDER' in window && window.UNIT_TEST_THUNDER;

var requestDefault = {
  method: 'GET',
  data: null,
  url: ''
};

function baseFetch(options, callback) {
  window.fetch(options.url, {
    method: options.method,
    body: options.body
  }).then(function (res) {
    if (!res.ok) return callback(res);
    return res.text();
  }).then(function (content) {
    callback(null, content);
  }).catch(callback);
}

function baseXMLHttpRequest(options, callback) {
  var xhr = new window.XMLHttpRequest();
  xhr.withCredentials = false;
  xhr.open(options.method, options.url, true);
  xhr.onreadystatechange = function () {
    // load end
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        xhr.onreadystatechange = null;
        callback(null, xhr.responseText);
      } else {
        // ajax load failed
        callback(new Error('ThunderError: content load failed'));
      }
    }
  };
  xhr.send(options.body);
}

/*
* request
* @param options : String or Object
* @param cb : Function
*/
function _request(_options, callback) {
  if (!isBrowser) return callback(new Error('ThunderError: not in browser'));
  var options = {
    method: 'GET',
    data: null,
    url: '',
    body: undefined
  };
  if (typeof _options === 'string') {
    options.url = _options;
  } else {
    assign(options, _options);
  }
  // set default method
  if (!options.method) options.method = requestDefault.method;

  // force set uppercase
  options.method = options.method.toUpperCase();

  // format data to stringify body
  if (options.data) {
    options.body = JSON.stringify(options.data);
  }

  if (supportFetch) {
    return baseFetch(options, callback);
  }

  return baseXMLHttpRequest(options, callback);
}



function execModule(content, type, attrs) {
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;
  if (type === 'js') {
    el = document.createElement('script');
    el.type = 'text/javascript';
    el.charset = 'utf-8';
    el.text = content;
  } else {
    el = document.createElement('style');
    el.type = 'text/css';
    el.charset = 'utf-8';
    el.textContent = content;
  }
  if (attrs) {
    keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }
  head.appendChild(el);
  if (typeof el.onload === 'function') el.onload();
  return el;
}

function getScriptElement(link) {
  var el = document.createElement('script');
  el.type = 'text/javascript';
  el.charset = 'utf-8';
  el.async = true;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function getLinkElement(link) {
  var el = document.createElement('link');
  el.rel = 'stylesheet';
  el.href = link;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function execModuleAsyncLoad(link, type, attrs, callback) {
  // start chunk loading
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;

  if (type === 'js') {
    el = getScriptElement(link);
    if (attrs) {
      keys(attrs).forEach(function (key) {
        el.setAttribute(key, attrs[key]);
      });
    }
  } else if (type === 'css') {
    el = getLinkElement(link);
  }

  if (!el) return callback(new Error('execModuleAsyncLoad: wrong type with ' + type));
  var _onerror = noop;
  var _onload = noop;

  if (typeof el.onerror === 'function') _onerror = el.onerror;
  if (typeof el.onload === 'function') _onload = el.onload;

  el.onerror = onScriptError;
  el.onload = onScriptComplete;

  var timer = setTimeout(function () {
    onScriptError(new Error('execModuleAsyncLoad: timeout ' + link));
  }, 120000);

  function onScriptError(msg) {
    _onerror();
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(msg);
  }

  function onScriptComplete() {
    _onload();
    // avoid mem leaks in IE.
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(null, el);
  }
  head.appendChild(el);
  return el;
}



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function keys(obj) {
  if (!isUnitTest && Object.keys) return Object.keys(obj);
  if (obj !== Object(obj)) {
    throw new TypeError('Object.keys called on a non-object');
  }
  var keys = [];
  var key = void 0;
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
}

function noop() {}

// Copyright (C) 2014-present  SheetJS

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// modify by longjiawen@meituan.com

var T = signedCrcTable();

function signedCrcTable() {
  var c = 0;
  var table = new Array(256);

  for (var n = 0; n !== 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }

  return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

function crc32Str(str, seed) {
  var C = seed ^ -1;
  for (var i = 0, L = str.length, c, d; i < L;) {
    c = str.charCodeAt(i++);
    if (c < 0x80) {
      C = C >>> 8 ^ T[(C ^ c) & 0xFF];
    } else if (c < 0x800) {
      C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    } else if (c >= 0xD800 && c < 0xE000) {
      c = (c & 1023) + 64;d = str.charCodeAt(i++) & 1023;
      C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 0xFF];
    } else {
      C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    }
  }
  return (C ^ -1) >>> 0;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var Chunk = function () {
  function Chunk(name, state, options) {
    classCallCheck(this, Chunk);

    this.type = state.type || '';
    this.name = name;
    this.state = state;
    this.options = options;
    this.store = options.store;
    this.logger = options.logger;
    this._updateAdapter = options.updateAdapter;
    this._content = state.content || '';
  }

  createClass(Chunk, [{
    key: '_runScript',
    value: function _runScript() {
      if (!this.state.runScript) return;
      execModule(this.state.runScript, 'js', this.attrs);
    }
  }, {
    key: '_request',
    value: function _request$$1(cb) {
      var _this = this;

      // read from HTTP
      _request(this.link, function (err, content) {
        if (err) {
          return _request(_this.fallbackLink, function (_err, content) {
            if (_err) cb(_err);
            _this._content = content;
            cb();
          });
        }
        _this._content = content;
        cb();
      });
    }
  }, {
    key: 'check',
    value: function check() {
      // if state.checksum is not exist, just skip
      // 例如：外链资源
      if (typeof this.state.checksum === 'undefined') return true;

      var checksum = crc32Str(this._content);
      var isMatch = checksum === this.state.checksum;
      this.logger.markOnce('check:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'chunkChecksum',
        size: Math.floor(this._content.length / 1024),
        originChecksum: this.state.checksum,
        isMatch: isMatch,
        currentChecksum: checksum
      });
      return isMatch;
    }
  }, {
    key: 'render',
    value: function render() {
      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        execModule(this._content, this.type, this.attrs);
        this._runScript();
      } else {
        // 1. 没有 _content, 加载失败
        // 2. checksum 校验和不匹配
        return this.fallback();
      }
    }
  }, {
    key: 'fallback',
    value: function fallback() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2._fallback(function (err) {
          if (err) return reject(err);
          resolve();
        });
      });
    }
  }, {
    key: '_fallback',
    value: function _fallback(done) {
      var _this3 = this;

      // inline chunk
      if (this.state.content) {
        execModule(this.state.content, this.type, this.attrs);
        return done();
      }
      // fallback
      execModuleAsyncLoad(this.link, this.type, this.attrs, function (err) {
        // success
        if (!err) {
          _this3._runScript();
          return done();
        }

        _this3.logger.markOnce('bootloader:' + _this3.cacheKey, {
          chunkName: _this3.cacheKey,
          reason: 'bootFailure'
        });

        // try again fallback link
        execModuleAsyncLoad(_this3.fallbackLink, _this3.type, _this3.attrs, function (reErr) {
          if (reErr) {
            _this3.logger.markOnce('bootloader:' + _this3.cacheKey, {
              chunkName: _this3.cacheKey,
              reason: 'bootFallbackFailure'
            });
            return done(reErr);
          }
          _this3._runScript();
          done();
        });
      });
    }
  }, {
    key: 'cacheKey',
    get: function get$$1() {
      return '<' + this.type + '>:' + this.name;
    }
  }, {
    key: 'link',
    get: function get$$1() {
      if (this.state.link) {
        return this.state.link;
      } else {
        return this.options.config.publicPath + this.filename;
      }
    }
  }, {
    key: 'fallbackLink',
    get: function get$$1() {
      // if link exist (外链资源), use link
      if (this.state.link) {
        return this.state.link;
      } else {
        // if fallbackCDN doesn't exist, use publicPath instead
        return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename;
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }, {
    key: 'attrs',
    get: function get$$1() {
      return assign({
        'thunder-cache-key': this.cacheKey,
        'crossorigin': this.options.config.crossOriginLoading
      }, this.options.attrs, this.state.attrs);
    }
  }]);
  return Chunk;
}();

var BootLogger = function () {
  function BootLogger(options) {
    classCallCheck(this, BootLogger);

    this.options = options;
    this._logQueue = [];
    this._logger = null;
  }

  createClass(BootLogger, [{
    key: 'set',
    value: function set$$1(logger) {
      this._logger = logger;
      this.send();
    }
  }, {
    key: 'send',
    value: function send() {
      if (!this._logger) return;
      this._logger.logQueue = this._logger.logQueue.concat(this._logQueue);
      this._logQueue.length = 0;
      this._logger.report();
    }
  }, {
    key: 'markOnce',
    value: function markOnce(key, data) {
      var log = {
        key: key,
        data: assign({
          channel: 'lx',
          from: 'bootloader',
          version: this.options.version,
          project: this.options.project,
          starkAppKey: this.options.starkAppKey
        }, data)
      };
      this._logQueue.push(log);
      this.send();
    }
  }]);
  return BootLogger;
}();

var ThunderBootloader = function () {
  function ThunderBootloader(state) {
    classCallCheck(this, ThunderBootloader);

    this.state = state;
    this._chunks = [];
    this.running = true;
    this.type = 'bootloader';
    this.version = '2.3.7';
    this.project = this.state.project;
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : '';
    this.logger = new BootLogger({
      version: this.version,
      project: this.state.project,
      starkAppKey: this.starkAppKey
    });
    this._chunkOptions = {
      attrs: assign({}, this.state.outputOptions.attrs),
      config: this.state.outputOptions,
      cacheAge: this.state.cacheAge,
      store: null,
      logger: this.logger,
      updateAdapter: null
    };
    this._thunderCacheKey = 'Thunder#' + (this.starkAppKey || this.project) + ':sdk';
    this.thunderSDKChunk = new Chunk('thunder-sdk', assign({
      type: 'js'
    }, this.state.outputOptions.thunder), this._chunkOptions);
    this._thunder = null;
    this._records = [];
    this._timer = null;
    this.init();
  }

  createClass(ThunderBootloader, [{
    key: 'init',
    value: function init() {
      var _this = this;

      if (isBrowser) {
        window.__thunder__ = this;
      }
      this.tryInitThunder();
      if (this._thunder) return;
      this.state.resources.map(function (r) {
        _this._chunks.push(new Chunk(r.name, r, _this._chunkOptions));
      });
    }
  }, {
    key: 'tryInitThunder',
    value: function tryInitThunder() {
      if (!supportLS) return;
      try {
        // sdk cache exist
        if (localStorage[this._thunderCacheKey]) {
          this.thunderSDKChunk._content = localStorage[this._thunderCacheKey];
          return this._createThunder();
        }
      } catch (e) {
        console.error(e);
      }
      // non content, try load thunder SDK
      this._setLoadThunderJob();
    }
  }, {
    key: '_setLoadThunderJob',
    value: function _setLoadThunderJob() {
      var _this2 = this;

      clearTimeout(this._timer);
      this._timer = setTimeout(function () {
        _this2.loadThunder();
      }, 1200);
    }
  }, {
    key: '_clearThunderCache',
    value: function _clearThunderCache() {
      localStorage.removeItem(this._thunderCacheKey);
    }
  }, {
    key: '_createThunder',
    value: function _createThunder() {
      if (!this.thunderSDKChunk._content) return;
      this.thunderSDKChunk.render();
      if (!('Thunder' in window) || this instanceof window.Thunder) return this._clearThunderCache();
      var thunder = new window.Thunder(this.state);
      this._thunder = thunder;
      this.logger.markOnce('bootInit', {
        reason: 'bootInit'
      });
      assign(thunder._chunkOptions.attrs, this._chunkOptions.attrs);
      assign(thunder._chunkOptions.config, this._chunkOptions.config);
      this.logger.set(thunder.logger);
      this._records.forEach(function (_ref) {
        var chunkNames = _ref.chunkNames,
            type = _ref.type;

        // load and cache only
        var chunks = thunder._getChunks(chunkNames, type);
        Promise.all(chunks.map(function (c) {
          return c.load();
        })).then(function () {
          console.log('cached!');
        });
      });
    }
  }, {
    key: 'loadThunder',
    value: function loadThunder() {
      var _this3 = this;

      var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

      if (this._thunder) return cb();
      this.thunderSDKChunk._request(function (err) {
        _this3.logger.markOnce('bootLoadThunder', {
          reason: 'bootLoadThunder',
          success: !err,
          message: err && err.message || ''
        });
        if (err) return cb(err);
        if (!_this3.thunderSDKChunk._content) return cb(new Error('loadThunder: empty js content'));
        localStorage[_this3._thunderCacheKey] = _this3.thunderSDKChunk._content;
        _this3._createThunder();
        cb();
      });
    }
  }, {
    key: 'load',
    value: function load(jobs, cb) {
      var _this4 = this;

      if (!('Promise' in window)) {
        // set running to false, webpack async chunk will not use thunder
        this.running = false;
        // unsupport Promsie, try load thunder sdk
        return this.loadThunder(function (err) {
          // try once
          if (err) {
            return _this4.loadThunder(function () {
              return _this4._load(jobs, cb);
            });
          }
          return _this4._load(jobs, cb);
        });
      }
      return this._load(jobs, cb);
    }
  }, {
    key: 'bundleLoader',
    value: function bundleLoader(chunkNames) {
      return this.parallel(chunkNames, 'js');
    }
  }, {
    key: 'scriptLoader',
    value: function scriptLoader(chunkNames) {
      return this.parallel(chunkNames, 'js');
    }
  }, {
    key: 'styleLoader',
    value: function styleLoader(chunkNames) {
      return this.parallel(chunkNames, 'css');
    }
  }, {
    key: 'parallel',
    value: function parallel(chunkNames) {
      var _this5 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'js';

      if (this._thunder) return this._thunder.parallel(chunkNames, type);
      this._records.push({
        chunkNames: chunkNames,
        type: type
      });

      var chunks = this._getChunks(chunkNames, type);
      var queue = Promise.resolve();
      chunks.forEach(function (c) {
        queue = queue.then(function () {
          return c.fallback();
        });
      });
      queue.then(function () {
        _this5._setLoadThunderJob();
      });
      return queue;
    }
  }, {
    key: '_load',
    value: function _load(jobs, cb) {
      var _this6 = this;

      var queue = Promise.resolve();
      jobs.forEach(function (job) {
        job.action = job.action || 'load';
        if (job.action !== 'load') return;
        queue = queue.then(function () {
          return _this6.parallel(job.chunks, job.type);
        });
      });
      queue.then(function () {
        if (cb) cb();
      });
      return queue;
    }

    /*
    * @internal
    * _getChunks
    * @param chunkNames <String> Array or String
    * @param type String
    * @return <Chunk> Array
    */

  }, {
    key: '_getChunks',
    value: function _getChunks(_chunkNames) {
      var _this7 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'js';

      var chunkNames = void 0;
      var chunks = [];

      if (typeof _chunkNames === 'string') {
        chunkNames = [_chunkNames];
      } else {
        chunkNames = _chunkNames;
      }

      chunkNames.forEach(function (name) {
        _this7._chunks.forEach(function (c) {
          if (c.type === type && name === c.name) {
            chunks.push(c);
          }
        });
      });

      return chunks;
    }
  }]);
  return ThunderBootloader;
}();

return ThunderBootloader;

})));
