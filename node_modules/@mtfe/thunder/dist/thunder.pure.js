/*!
 * Thunder.js v2.3.7
 * (c) 2019-07-02 14:28:13 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Thunder = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined';

// inspired by https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
var supportLS = function (storage) {
  if (!storage) return false;
  try {
    var key = '__LS_SUPPORT_TEST_KEY__';
    storage.setItem(key, key);
    storage.removeItem(key, key);
    return true;
  } catch (e) {
    return false;
  }
}(window.localStorage);

var isDEBUG = isBrowser && 'DEBUG_THUNDER' in window && window.DEBUG_THUNDER;
var supportFetch = isBrowser && 'fetch' in window;
var isUnitTest = isBrowser && 'UNIT_TEST_THUNDER' in window && window.UNIT_TEST_THUNDER;

var requestDefault = {
  method: 'GET',
  data: null,
  url: ''
};

function baseFetch(options, callback) {
  window.fetch(options.url, {
    method: options.method,
    body: options.body
  }).then(function (res) {
    if (!res.ok) return callback(res);
    return res.text();
  }).then(function (content) {
    callback(null, content);
  }).catch(callback);
}

function baseXMLHttpRequest(options, callback) {
  var xhr = new window.XMLHttpRequest();
  xhr.withCredentials = false;
  xhr.open(options.method, options.url, true);
  xhr.onreadystatechange = function () {
    // load end
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        xhr.onreadystatechange = null;
        callback(null, xhr.responseText);
      } else {
        // ajax load failed
        callback(new Error('ThunderError: content load failed'));
      }
    }
  };
  xhr.send(options.body);
}

/*
* request
* @param options : String or Object
* @param cb : Function
*/
function _request(_options, callback) {
  if (!isBrowser) return callback(new Error('ThunderError: not in browser'));
  var options = {
    method: 'GET',
    data: null,
    url: '',
    body: undefined
  };
  if (typeof _options === 'string') {
    options.url = _options;
  } else {
    assign(options, _options);
  }
  // set default method
  if (!options.method) options.method = requestDefault.method;

  // force set uppercase
  options.method = options.method.toUpperCase();

  // format data to stringify body
  if (options.data) {
    options.body = JSON.stringify(options.data);
  }

  if (supportFetch) {
    return baseFetch(options, callback);
  }

  return baseXMLHttpRequest(options, callback);
}

function request(options) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

  return new Promise(function (resolve, reject) {
    _request(options, function (err, content) {
      if (err) {
        cb(err);
        reject(err);
      } else {
        cb(null, content);
        resolve(content);
      }
    });
  });
}

function execModule(content, type, attrs) {
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;
  if (type === 'js') {
    el = document.createElement('script');
    el.type = 'text/javascript';
    el.charset = 'utf-8';
    el.text = content;
  } else {
    el = document.createElement('style');
    el.type = 'text/css';
    el.charset = 'utf-8';
    el.textContent = content;
  }
  if (attrs) {
    keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }
  head.appendChild(el);
  if (typeof el.onload === 'function') el.onload();
  return el;
}

function getScriptElement(link) {
  var el = document.createElement('script');
  el.type = 'text/javascript';
  el.charset = 'utf-8';
  el.async = true;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function getLinkElement(link) {
  var el = document.createElement('link');
  el.rel = 'stylesheet';
  el.href = link;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function execModuleAsyncLoad(link, type, attrs, callback) {
  // start chunk loading
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;

  if (type === 'js') {
    el = getScriptElement(link);
    if (attrs) {
      keys(attrs).forEach(function (key) {
        el.setAttribute(key, attrs[key]);
      });
    }
  } else if (type === 'css') {
    el = getLinkElement(link);
  }

  if (!el) return callback(new Error('execModuleAsyncLoad: wrong type with ' + type));
  var _onerror = noop;
  var _onload = noop;

  if (typeof el.onerror === 'function') _onerror = el.onerror;
  if (typeof el.onload === 'function') _onload = el.onload;

  el.onerror = onScriptError;
  el.onload = onScriptComplete;

  var timer = setTimeout(function () {
    onScriptError(new Error('execModuleAsyncLoad: timeout ' + link));
  }, 120000);

  function onScriptError(msg) {
    _onerror();
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(msg);
  }

  function onScriptComplete() {
    _onload();
    // avoid mem leaks in IE.
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(null, el);
  }
  head.appendChild(el);
  return el;
}

function debug() {
  /* istanbul ignore next */
  if (!isDEBUG) return;

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var type = args[0];
  var logger = void 0;
  /* istanbul ignore if */
  if (console[type]) {
    logger = console[type];
    args.shift();
  } else {
    logger = console.log;
  }
  args.unshift('[Thunder]');
  logger.apply(console, args);
}

function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function keys(obj) {
  if (!isUnitTest && Object.keys) return Object.keys(obj);
  if (obj !== Object(obj)) {
    throw new TypeError('Object.keys called on a non-object');
  }
  var keys = [];
  var key = void 0;
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
}

function noop() {}



var fakeLogger = {
  markOnce: noop,
  mark: noop,
  markEnd: noop
};

// Copyright (C) 2014-present  SheetJS

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// modify by longjiawen@meituan.com

var T = signedCrcTable();

function signedCrcTable() {
  var c = 0;
  var table = new Array(256);

  for (var n = 0; n !== 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }

  return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

function crc32Str(str, seed) {
  var C = seed ^ -1;
  for (var i = 0, L = str.length, c, d; i < L;) {
    c = str.charCodeAt(i++);
    if (c < 0x80) {
      C = C >>> 8 ^ T[(C ^ c) & 0xFF];
    } else if (c < 0x800) {
      C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    } else if (c >= 0xD800 && c < 0xE000) {
      c = (c & 1023) + 64;d = str.charCodeAt(i++) & 1023;
      C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 0xFF];
    } else {
      C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    }
  }
  return (C ^ -1) >>> 0;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Chunk = function () {
  function Chunk(name, state, options) {
    classCallCheck(this, Chunk);

    this.type = '';
    this.name = name;
    this.state = state;
    this.options = options;
    this.store = options.store;
    this.logger = options.logger;
    this._updateAdapter = options.updateAdapter;
    this._content = '';
  }

  createClass(Chunk, [{
    key: 'load',
    value: function load() {
      return this.getContent().then(noop, function (e) {
        console.error(e);
        // 获取失败时跳过，在 render 中执行缺少 content, 会执行 JSONP fallback
      });
    }
  }, {
    key: 'check',
    value: function check() {
      // if state.checksum is not exist, just skip
      // 例如：外链资源
      if (typeof this.state.checksum === 'undefined') return true;

      this.logger.mark('check:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'chunkChecksum',
        size: Math.floor(this._content.length / 1024),
        originChecksum: this.state.checksum,
        reportCost: true
      });
      var checksum = crc32Str(this._content);
      var isMatch = checksum === this.state.checksum;
      this.logger.markEnd('check:' + this.cacheKey, {
        isMatch: isMatch,
        currentChecksum: checksum
      });

      if (isMatch) return isMatch;
      // if not match，call clear
      this.store.remove(this.cacheKey);
      return false;
    }
  }, {
    key: '_request',
    value: function _request$$1() {
      var _this = this;

      // read from HTTP
      return new Promise(function (resolve, reject) {
        request(_this.link, function (err, content) {
          if (err) {
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullFailure',
              reportCost: true
            });
            return reject(err);
          } else {
            _this._content = content;
            _this.store.add({
              name: _this.cacheKey,
              hash: _this.hash,
              cacheAge: _this.state.cacheAge || _this.options.cacheAge,
              content: _this._content,
              filename: _this.filename
            });
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullSuccess',
              reportCost: true
            });
            resolve(content);
          }
        });
      });
    }
  }, {
    key: 'update',
    value: function update(cached) {
      var _this2 = this;

      return this._updateAdapter(this.name, {
        localChunk: cached,
        remoteChunk: this.state
      }).then(function (payload) {
        // diff failed or skiped
        if (!payload || !payload.content) return _this2._request();

        // diff success
        _this2._content = payload.content;
        _this2.store.add({
          name: _this2.cacheKey,
          hash: _this2.hash,
          cacheAge: _this2.state.cacheAge || _this2.options.cacheAge,
          content: _this2._content,
          filename: _this2.filename
        });
        return _this2._content;
      }, function (e) {
        // diff failed
        console.error(e);
        return _this2._request();
      });
    }
  }, {
    key: 'getContent',
    value: function getContent() {
      var _this3 = this;

      if (this._content) return Promise.resolve(this._content);
      this.logger.markOnce('request:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'request'
      });
      this.logger.mark('async:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reportCost: true
      });
      // read from CacheStore
      return this.store.get(this.cacheKey).then(function (cached) {
        // no cache
        // read from HTTP
        if (!cached) return _this3._request();

        // has local Cache
        var content = cached.content,
            hash = cached.hash;
        // version matched

        if (_this3.hash === hash) {
          _this3.logger.markEnd('async:' + _this3.cacheKey, {
            reason: _this3.store.type,
            reportCost: true
          });
          _this3._content = content;
          return Promise.resolve(_this3._content);
        } else {
          // version not matched, try update
          return _this3.update(cached);
        }
      });
    }
  }, {
    key: 'fallback',
    value: function fallback() {
      var _this4 = this;

      var execFallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModuleAsyncLoad;

      this.logger.mark('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'fallbackStart'
      });
      return new Promise(function (resolve, reject) {
        // fallback
        execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (err) {
          // success
          if (!err) {
            _this4.fallbackState = 'fallbackSuccessFrist';
            return resolve();
          }
          // try again fallback link
          execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (reErr) {
            if (!reErr) {
              _this4.fallbackState = 'fallbackSuccessSecond';
              return resolve();
            }
            _this4.fallbackState = 'fallbackFailure';
            reject(reErr);
          });
        });
      });
    }
  }, {
    key: 'cacheKey',
    get: function get$$1() {
      return '<' + this.type + '>:' + this.name;
    }
  }, {
    key: 'hash',
    get: function get$$1() {
      return this.state.hash || this.filename || this.link;
    }
  }, {
    key: 'link',
    get: function get$$1() {
      if (this.state.link) {
        return this.state.link;
      } else {
        return this.options.config.publicPath + this.filename;
      }
    }
  }, {
    key: 'fallbackState',
    set: function set$$1(value) {
      this.logger.markEnd('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: value
      });
    }
  }, {
    key: 'fallbackLink',
    get: function get$$1() {
      // if link exist (外链资源), use link
      if (this.state.link) {
        return this.state.link;
      } else {
        // if fallbackCDN doesn't exist, use publicPath instead
        return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename;
      }
    }
  }, {
    key: 'attrs',
    get: function get$$1() {
      return assign({
        'thunder-cache-key': this.cacheKey,
        'crossorigin': this.options.config.crossOriginLoading
      }, this.options.attrs, this.state.attrs);
    }
  }]);
  return Chunk;
}();

var JSStaticType = 'js';

var ScriptChunk = function (_Chunk) {
  inherits(ScriptChunk, _Chunk);

  function ScriptChunk(name, state, options) {
    classCallCheck(this, ScriptChunk);

    var _this = possibleConstructorReturn(this, (ScriptChunk.__proto__ || Object.getPrototypeOf(ScriptChunk)).call(this, name, state, options));

    _this.type = JSStaticType;
    return _this;
  }

  createClass(ScriptChunk, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(execModule(this._content, 'js', this.attrs)).then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      } else {
        // 1. 没有 _content, 加载失败
        // 2. checksum 校验和不匹配
        return this.fallback().then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return JSStaticType;
    }
  }]);
  return ScriptChunk;
}(Chunk);

var CSSStaticType = 'css';

var StyleChunk = function (_Chunk) {
  inherits(StyleChunk, _Chunk);

  function StyleChunk(name, state, options) {
    classCallCheck(this, StyleChunk);

    var _this = possibleConstructorReturn(this, (StyleChunk.__proto__ || Object.getPrototypeOf(StyleChunk)).call(this, name, state, options));

    _this.type = CSSStaticType;
    return _this;
  }

  createClass(StyleChunk, [{
    key: 'render',


    /*
    * render
    * @param exec
    * @param execFallback
    */
    value: function render() {
      var exec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModule;
      var execFallback = arguments[1];

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(exec(this._content, 'css', this.attrs));
      } else {
        return this.fallback(execFallback);
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return CSSStaticType;
    }
  }]);
  return StyleChunk;
}(Chunk);

var Thunder$1 = function () {
  function Thunder(state) {
    classCallCheck(this, Thunder);

    this.state = state;
    this.version = '2.3.7';
    this.running = true;
    this.type = 'tiny';
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : '';
    this._chunks = [];
    this.init();
  }

  createClass(Thunder, [{
    key: 'set',
    value: function set$$1() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          nonce = _ref.nonce,
          publicPath = _ref.publicPath,
          attrs = _ref.attrs,
          fallbackCDN = _ref.fallbackCDN;

      if (nonce) this._chunkOptions.attrs.nonce = nonce;
      if (attrs) assign(this._chunkOptions.attrs, attrs);
      if (publicPath) this._chunkOptions.config.publicPath = publicPath;
      if (fallbackCDN) this._chunkOptions.config.fallbackCDN = fallbackCDN;
    }
  }, {
    key: 'init',
    value: function init() {
      var _this = this;

      if (isBrowser) {
        window.__thunder__ = this;
      }
      Thunder._installedPlugins.forEach(function (plugin) {
        return plugin(_this);
      });
      if (!this.logger) this.logger = fakeLogger;
      this._chunkOptions = {
        attrs: assign({}, this.state.outputOptions.attrs),
        config: this.state.outputOptions,
        cacheAge: this.state.cacheAge,
        store: this.store,
        logger: this.logger,
        updateAdapter: this.updateAdapter.bind(this)
        // match resource
        // js -> create scriptChunk instance
        // css -> create styleChunk instance
      };this.state.resources.forEach(function (resource) {
        Thunder.Chunks.forEach(function (ChunkConstructor) {
          if (resource.type !== ChunkConstructor.type) return;
          _this._chunks.push(new ChunkConstructor(resource.name, resource, _this._chunkOptions));
        });
      });
      // prepare clear unexist chunk cache
      this.store.saveChunksMap(this._chunks.map(function (c) {
        return c.cacheKey;
      }));

      this.logger.markOnce('init', {
        channel: 'lx',
        SWSupport: this.serviceWorkerManager && this.serviceWorkerManager.isSupport(),
        useSW: !!this.state.serviceWorker,
        reason: 'init'
      });
    }
  }, {
    key: 'updateAdapter',
    value: function updateAdapter(chunkName, preUpdateData) {
      if (!this._updateAdapter) return Promise.resolve();
      return this._updateAdapter(chunkName, preUpdateData, this, {
        Promise: Promise,
        request: request,
        debug: debug,
        logger: this.logger
      });
    }
  }, {
    key: 'bundleLoader',
    value: function bundleLoader(chunkName) {
      return this.parallel(chunkName);
    }
  }, {
    key: 'styleLoader',
    value: function styleLoader(chunkName) {
      return this.parallelStyle(chunkName);
    }
  }, {
    key: 'parallelStyle',
    value: function parallelStyle(chunkNames) {
      return this.parallel(chunkNames, 'css');
    }
  }, {
    key: 'load',
    value: function load(jobs, cb) {
      var _this2 = this;

      var queue = Promise.resolve();
      // load
      jobs.forEach(function (job) {
        job.action = job.action || 'load';
        if (job.action === 'load') {
          queue = queue.then(function () {
            return _this2.parallel(job.chunks, job.type);
          });
        }
      });
      // prefetch
      jobs.forEach(function (job) {
        if (job.action === 'prefetch') {
          queue = queue.then(function () {
            return _this2.prefetch(job.chunks, job.type);
          });
        }
      });
      queue.then(function () {
        if (cb) cb();
      });
      return queue;
    }
  }, {
    key: 'parallel',
    value: function parallel(chunkNames, type) {
      var chunks = this._getChunks(chunkNames, type);

      return Promise.all(chunks.map(function (c) {
        return c.load();
      })).then(function () {
        var queue = Promise.resolve();
        chunks.forEach(function (c) {
          queue = queue.then(function () {
            return c.render();
          });
        });
        return queue;
      }).catch(function (err) {
        return console.error(err);
      });
    }
  }, {
    key: 'prefetch',
    value: function prefetch() {
      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // delay 500ms
      var prefetchChunks = this._getChunks(chunks);
      prefetchChunks = prefetchChunks.concat(this._getChunks(chunks, 'css'));
      return new Promise(function (resolve, reject) {
        setTimeout(resolve, 500);
      }).then(function () {
        var unloadChunks = [];
        prefetchChunks.map(function (c) {
          if (!c._content) unloadChunks.push(c);
        });
        return Promise.all(unloadChunks.map(function (c) {
          return c.getContent();
        }));
      });
    }

    /*
    * @internal
    * _getChunks
    * @param chunkNames <String> Array or String
    * @param type String
    * @return <Chunk> Array
    */

  }, {
    key: '_getChunks',
    value: function _getChunks(_chunkNames) {
      var _this3 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'js';

      var chunkNames = void 0;
      var chunks = [];

      if (typeof _chunkNames === 'string') {
        chunkNames = [_chunkNames];
      } else {
        chunkNames = _chunkNames;
      }

      chunkNames.forEach(function (name) {
        _this3._chunks.forEach(function (c) {
          if (c.type === type && name === c.name) {
            chunks.push(c);
          }
        });
      });

      return chunks;
    }
  }]);
  return Thunder;
}();

Thunder$1.StyleChunk = StyleChunk;
Thunder$1.ScriptChunk = ScriptChunk;
Thunder$1.BaseChunk = Chunk;
Thunder$1.Chunks = [StyleChunk, ScriptChunk];

Thunder$1._installedPlugins = [];

Thunder$1.use = function use() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var plugin = args.shift();
  var installedPlugins = this._installedPlugins;
  if (!plugin || installedPlugins.indexOf(plugin) > -1) {
    return this;
  }
  // args.unshift(this)
  // if (typeof plugin.install === 'function') {
  //   plugin.install.apply(plugin, args)
  // } else if (typeof plugin === 'function') {
  //   plugin.apply(null, args)
  // }
  installedPlugins.push(plugin);
  return this;
};

var THUNDER_KEY = 'Thunder';

var LSStorage = function () {
  function LSStorage(_ref) {
    var version = _ref.version,
        _ref$project = _ref.project,
        project = _ref$project === undefined ? '' : _ref$project;
    classCallCheck(this, LSStorage);

    this.type = 'LSCache';
    this.prefix = THUNDER_KEY + '#' + project;
    this._storekey = this.prefix + ':store';
    this.storage = supportLS && window.localStorage;
    this.state = {
      size: 0,
      count: 0,
      version: version,
      cacheMap: {},
      chunks: []
    };
    this._delay = 100;
    this._saveTimer = null;
    this._load();
  }

  createClass(LSStorage, [{
    key: '_save',
    value: function _save() {
      var _this = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._delay;

      if (!supportLS) return;
      var job = function job() {
        var stateRaw = JSON.stringify(_this.state);
        try {
          _this.storage.setItem(_this._storekey, stateRaw);
        } catch (e) {
          _this.clear();
          debug('error', e);
        }
      };
      if (delay === 0) {
        return job();
      }
      if (this._saveTimer) clearTimeout(this._saveTimer);
      this._saveTimer = setTimeout(function () {
        job();
      }, delay);
    }
  }, {
    key: '_load',
    value: function _load() {
      if (!supportLS) return;
      try {
        this.storage.setItem(THUNDER_KEY + '?v', this.state.version);
        var stateRaw = this.storage.getItem(this._storekey);
        if (!stateRaw) return;
        var state = JSON.parse(stateRaw);
        if (this._schemaCheck(state)) {
          this.state = state;
        }
      } catch (e) {
        this.clear();
        debug('error', e);
      }
    }
  }, {
    key: '_schemaCheck',
    value: function _schemaCheck(state) {
      var _this2 = this;

      var seem = true;
      var toString = Object.prototype.toString;
      keys(this.state).forEach(function (key) {
        if (!seem) return;
        seem = toString.call(state[key]) === toString.call(_this2.state[key]);
      });
      keys(state).forEach(function (key) {
        if (_this2.state[key] === undefined) {
          seem = false;
        }
      });
      return seem;
    }
  }, {
    key: '_getChunkName',
    value: function _getChunkName(chunkName) {
      return this.prefix + '~' + chunkName;
    }
  }, {
    key: '_updateStateInfo',
    value: function _updateStateInfo() {
      var _this3 = this;

      var size = 0;
      var count = 0;

      keys(this.state.cacheMap).forEach(function (key) {
        size += _this3.state.cacheMap[key].size || 0;
        count++;
      });

      this.state.size = size;
      this.state.count = count;
    }
  }, {
    key: 'saveChunksMap',
    value: function saveChunksMap(chunks) {
      this.state.chunks = chunks;
      this._save(0);
      this.clearAbandonedChunkCache(chunks);
    }

    /*
    * clearAbandonedChunkCache
    */

  }, {
    key: 'clearAbandonedChunkCache',
    value: function clearAbandonedChunkCache(chunks) {
      var _this4 = this;

      if (!supportLS) return;
      var cacheContentPrefix = this.prefix + '~';
      var preReg = new RegExp(cacheContentPrefix);
      var contentKeys = [];

      keys(this.storage).forEach(function (cacheKey) {
        if (preReg.test(cacheKey)) {
          contentKeys.push(cacheKey.replace(cacheContentPrefix, ''));
        }
      });

      contentKeys.forEach(function (cacheKey) {
        if (chunks.indexOf(cacheKey) === -1) {
          _this4.remove(cacheKey);
        }
      });
    }

    /*
      * get
      * @param url : String
      * @return Object or null
      */

  }, {
    key: '_get',
    value: function _get(name) {
      if (!supportLS) return null;
      var content = this.storage.getItem(this._getChunkName(name));
      var cacheData = this.state.cacheMap[name];

      // check exist
      if (!content || !cacheData) {
        this.remove(name);
        return null;
      }

      // check expire
      if (cacheData.expireAt) {
        var now = Date.now();
        if (cacheData.expireAt < now) return null;
      }

      return _extends({}, cacheData, {
        content: content
      });
    }

    /*
      * get
      * @param url : String
      * @return Object or null
      */

  }, {
    key: 'get',
    value: function get$$1(name) {
      return Promise.resolve(this._get(name));
    }

    /*
      * add
      * @param url : String
      * @param content : String
      * @return Boolean
      */

  }, {
    key: 'add',
    value: function add(payload) {
      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!supportLS) return false;
      try {
        var name = payload.name,
            hash = payload.hash,
            content = payload.content,
            filename = payload.filename,
            cacheAge = payload.cacheAge;

        this.storage.setItem(this._getChunkName(name), content);

        var now = Date.now();
        var expireAt = 0;

        if (cacheAge) {
          expireAt = now + cacheAge * 1000;
        }

        this.state.cacheMap[name] = {
          loadedAt: now,
          size: Math.round(content.length / 1024),
          hash: hash,
          expireAt: expireAt,
          filename: filename
        };

        this._updateStateInfo();

        this._save();

        return Promise.resolve(true);
      } catch (e) {
        if (retry) {
          this.retryAdd(payload, 3);
        }
        return Promise.resolve(false);
      }
    }
  }, {
    key: 'retryAdd',
    value: function retryAdd(payload, tryCount) {
      if (!tryCount) return debug('retry add failed  ' + payload.name + ' is too large: ' + Math.floor(payload.content.length / 1024) + ' KB');
      tryCount--;
      this.free();
      // when add failed try once
      if (!this.add(payload, false)) {
        this.retryAdd(payload, tryCount);
      } else {
        debug('retry add success', tryCount);
      }
    }

    /*
    * free
    * remove oldest chunk cache for ls
    */

  }, {
    key: 'free',
    value: function free() {
      var _this5 = this;

      var chunk = void 0;
      var chunkList = keys(this.state.cacheMap).map(function (chunkName) {
        chunk = _this5.state.cacheMap[chunkName];
        return {
          name: chunkName,
          // size: chunk.size,
          loadedAt: chunk.loadedAt
        };
      }).sort(function (a, b) {
        return a.loadedAt - b.loadedAt;
      });
      if (!chunkList.length) return;
      this.remove(chunkList[0].name);
    }
  }, {
    key: 'clear',
    value: function clear() {
      var _this6 = this;

      keys(this.state.cacheMap).forEach(function (chunkName) {
        _this6.remove(chunkName);
      });
    }
  }, {
    key: 'remove',
    value: function remove(chunkName) {
      if (!supportLS) return;
      var cache = this.state.cacheMap[chunkName];

      if (cache) {
        delete this.state.cacheMap[chunkName];
        this._updateStateInfo();
      }

      this.storage.removeItem(this._getChunkName(chunkName));
      this._save();
    }
  }]);
  return LSStorage;
}();

var Store = (function (thunder) {
  thunder.store = new LSStorage({
    project: thunder.starkAppKey || thunder.state.project,
    version: thunder.version
  });
});

Thunder$1.use(Store);

return Thunder$1;

})));
