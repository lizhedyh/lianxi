/*!
 * Thunder.js v2.3.7
 * (c) 2019-07-02 14:28:13 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Thunder = factory());
}(this, (function () { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/*
  es6-promise-polyfill
  v1.2.0 (c) lahmatiy
  MIT License https://github.com/lahmatiy/es6-promise-polyfill
*/
/* istanbul ignore next */
var Promise$1 = function (global) {
  //
  // Check for native Promise and it has correct interface
  //

  var NativePromise = global['Promise'];
  var nativePromiseSupported = NativePromise &&
  // Some of these methods are missing from
  // Firefox/Chrome experimental implementations
  'resolve' in NativePromise && 'reject' in NativePromise && 'all' in NativePromise && 'race' in NativePromise &&
  // Older version of the spec had a resolver object
  // as the arg rather than a function
  function () {
    var resolve;
    // eslint-disable-next-line
    new NativePromise(function (r) {
      resolve = r;
    });
    return typeof resolve === 'function';
  }();

  //
  // Polyfill
  //

  var PENDING = 'pending';
  var SEALED = 'sealed';
  var FULFILLED = 'fulfilled';
  var REJECTED = 'rejected';
  var NOOP = function NOOP() {};

  function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
  }

  // async calls
  var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
  var asyncQueue = [];
  var asyncTimer;

  function asyncFlush() {
    // run promise callbacks
    for (var i = 0; i < asyncQueue.length; i++) {
      asyncQueue[i][0](asyncQueue[i][1]);
    }

    // reset async asyncQueue
    asyncQueue = [];
    asyncTimer = false;
  }

  function asyncCall(callback, arg) {
    asyncQueue.push([callback, arg]);

    if (!asyncTimer) {
      asyncTimer = true;
      asyncSetTimer(asyncFlush, 0);
    }
  }

  function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
      resolve(promise, value);
    }

    function rejectPromise(reason) {
      reject(promise, reason);
    }

    try {
      resolver(resolvePromise, rejectPromise);
    } catch (e) {
      rejectPromise(e);
    }
  }

  function invokeCallback(subscriber) {
    var owner = subscriber.owner;
    var settled = owner.state_;
    var value = owner.data_;
    var callback = subscriber[settled];
    var promise = subscriber.then;

    if (typeof callback === 'function') {
      settled = FULFILLED;
      try {
        value = callback(value);
      } catch (e) {
        reject(promise, e);
      }
    }

    if (!handleThenable(promise, value)) {
      if (settled === FULFILLED) {
        resolve(promise, value);
      }

      if (settled === REJECTED) {
        reject(promise, value);
      }
    }
  }

  function handleThenable(promise, value) {
    var resolved;

    try {
      if (promise === value) {
        throw new TypeError('A promises callback cannot return that same promise.');
      }

      if (value && (typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {
        var then = value.then; // then should be retrived only once

        if (typeof then === 'function') {
          then.call(value, function (val) {
            if (!resolved) {
              resolved = true;

              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }
          }, function (reason) {
            if (!resolved) {
              resolved = true;

              reject(promise, reason);
            }
          });

          return true;
        }
      }
    } catch (e) {
      if (!resolved) {
        reject(promise, e);
      }

      return true;
    }

    return false;
  }

  function resolve(promise, value) {
    if (promise === value || !handleThenable(promise, value)) {
      fulfill(promise, value);
    }
  }

  function fulfill(promise, value) {
    if (promise.state_ === PENDING) {
      promise.state_ = SEALED;
      promise.data_ = value;

      asyncCall(publishFulfillment, promise);
    }
  }

  function reject(promise, reason) {
    if (promise.state_ === PENDING) {
      promise.state_ = SEALED;
      promise.data_ = reason;

      asyncCall(publishRejection, promise);
    }
  }

  function publish(promise) {
    var callbacks = promise.then_;
    promise.then_ = undefined;

    for (var i = 0; i < callbacks.length; i++) {
      invokeCallback(callbacks[i]);
    }
  }

  function publishFulfillment(promise) {
    promise.state_ = FULFILLED;
    publish(promise);
  }

  function publishRejection(promise) {
    promise.state_ = REJECTED;
    publish(promise);
  }

  /**
  * @class
  */
  function Promise(resolver) {
    if (typeof resolver !== 'function') {
      throw new TypeError('Promise constructor takes a function argument');
    }

    if (this instanceof Promise === false) {
      throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    }

    this.then_ = [];

    invokeResolver(resolver, this);
  }

  Promise.prototype = {
    constructor: Promise,

    state_: PENDING,
    then_: null,
    data_: undefined,

    then: function then(onFulfillment, onRejection) {
      var subscriber = {
        owner: this,
        then: new this.constructor(NOOP),
        fulfilled: onFulfillment,
        rejected: onRejection
      };

      if (this.state_ === FULFILLED || this.state_ === REJECTED) {
        // already resolved, call callback async
        asyncCall(invokeCallback, subscriber);
      } else {
        // subscribe
        this.then_.push(subscriber);
      }

      return subscriber.then;
    },

    'catch': function _catch(onRejection) {
      return this.then(null, onRejection);
    }
  };

  Promise.all = function (promises) {
    var Class = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.all().');
    }

    return new Class(function (resolve, reject) {
      var results = [];
      var remaining = 0;

      function resolver(index) {
        remaining++;
        return function (value) {
          results[index] = value;
          if (! --remaining) {
            resolve(results);
          }
        };
      }

      for (var i = 0, promise; i < promises.length; i++) {
        promise = promises[i];

        if (promise && typeof promise.then === 'function') {
          promise.then(resolver(i), reject);
        } else {
          results[i] = promise;
        }
      }

      if (!remaining) {
        resolve(results);
      }
    });
  };

  Promise.race = function (promises) {
    var Class = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.race().');
    }

    return new Class(function (resolve, reject) {
      for (var i = 0, promise; i < promises.length; i++) {
        promise = promises[i];

        if (promise && typeof promise.then === 'function') {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
    });
  };

  Promise.resolve = function (value) {
    var Class = this;

    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Class) {
      return value;
    }

    return new Class(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (reason) {
    var Class = this;

    return new Class(function (resolve, reject) {
      reject(reason);
    });
  };

  return nativePromiseSupported ? NativePromise : Promise;
}(typeof window !== 'undefined' ? window : typeof global !== 'undefined' && global || {});

var isBrowser = typeof window !== 'undefined';

// inspired by https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
var supportLS = function (storage) {
  if (!storage) return false;
  try {
    var key = '__LS_SUPPORT_TEST_KEY__';
    storage.setItem(key, key);
    storage.removeItem(key, key);
    return true;
  } catch (e) {
    return false;
  }
}(window.localStorage);

var isDEBUG = isBrowser && 'DEBUG_THUNDER' in window && window.DEBUG_THUNDER;
var supportFetch = isBrowser && 'fetch' in window;
var isUnitTest = isBrowser && 'UNIT_TEST_THUNDER' in window && window.UNIT_TEST_THUNDER;

var requestDefault = {
  method: 'GET',
  data: null,
  url: ''
};

function baseFetch(options, callback) {
  window.fetch(options.url, {
    method: options.method,
    body: options.body
  }).then(function (res) {
    if (!res.ok) return callback(res);
    return res.text();
  }).then(function (content) {
    callback(null, content);
  }).catch(callback);
}

function baseXMLHttpRequest(options, callback) {
  var xhr = new window.XMLHttpRequest();
  xhr.withCredentials = false;
  xhr.open(options.method, options.url, true);
  xhr.onreadystatechange = function () {
    // load end
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        xhr.onreadystatechange = null;
        callback(null, xhr.responseText);
      } else {
        // ajax load failed
        callback(new Error('ThunderError: content load failed'));
      }
    }
  };
  xhr.send(options.body);
}

/*
* request
* @param options : String or Object
* @param cb : Function
*/
function _request(_options, callback) {
  if (!isBrowser) return callback(new Error('ThunderError: not in browser'));
  var options = {
    method: 'GET',
    data: null,
    url: '',
    body: undefined
  };
  if (typeof _options === 'string') {
    options.url = _options;
  } else {
    assign(options, _options);
  }
  // set default method
  if (!options.method) options.method = requestDefault.method;

  // force set uppercase
  options.method = options.method.toUpperCase();

  // format data to stringify body
  if (options.data) {
    options.body = JSON.stringify(options.data);
  }

  if (supportFetch) {
    return baseFetch(options, callback);
  }

  return baseXMLHttpRequest(options, callback);
}

function request(options) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

  return new Promise(function (resolve, reject) {
    _request(options, function (err, content) {
      if (err) {
        cb(err);
        reject(err);
      } else {
        cb(null, content);
        resolve(content);
      }
    });
  });
}

function execModule(content, type, attrs) {
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;
  if (type === 'js') {
    el = document.createElement('script');
    el.type = 'text/javascript';
    el.charset = 'utf-8';
    el.text = content;
  } else {
    el = document.createElement('style');
    el.type = 'text/css';
    el.charset = 'utf-8';
    el.textContent = content;
  }
  if (attrs) {
    keys(attrs).forEach(function (key) {
      el.setAttribute(key, attrs[key]);
    });
  }
  head.appendChild(el);
  if (typeof el.onload === 'function') el.onload();
  return el;
}

function getScriptElement(link) {
  var el = document.createElement('script');
  el.type = 'text/javascript';
  el.charset = 'utf-8';
  el.async = true;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function getLinkElement(link) {
  var el = document.createElement('link');
  el.rel = 'stylesheet';
  el.href = link;
  el.timeout = 120000;
  el.src = link;
  return el;
}

function execModuleAsyncLoad(link, type, attrs, callback) {
  // start chunk loading
  var head = document.head || document.getElementsByTagName('head')[0];
  var el = void 0;

  if (type === 'js') {
    el = getScriptElement(link);
    if (attrs) {
      keys(attrs).forEach(function (key) {
        el.setAttribute(key, attrs[key]);
      });
    }
  } else if (type === 'css') {
    el = getLinkElement(link);
  }

  if (!el) return callback(new Error('execModuleAsyncLoad: wrong type with ' + type));
  var _onerror = noop;
  var _onload = noop;

  if (typeof el.onerror === 'function') _onerror = el.onerror;
  if (typeof el.onload === 'function') _onload = el.onload;

  el.onerror = onScriptError;
  el.onload = onScriptComplete;

  var timer = setTimeout(function () {
    onScriptError(new Error('execModuleAsyncLoad: timeout ' + link));
  }, 120000);

  function onScriptError(msg) {
    _onerror();
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(msg);
  }

  function onScriptComplete() {
    _onload();
    // avoid mem leaks in IE.
    el.onerror = el.onload = null;
    clearTimeout(timer);
    callback(null, el);
  }
  head.appendChild(el);
  return el;
}

function debug() {
  /* istanbul ignore next */
  if (!isDEBUG) return;

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var type = args[0];
  var logger = void 0;
  /* istanbul ignore if */
  if (console[type]) {
    logger = console[type];
    args.shift();
  } else {
    logger = console.log;
  }
  args.unshift('[Thunder]');
  logger.apply(console, args);
}

function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function keys(obj) {
  if (!isUnitTest && Object.keys) return Object.keys(obj);
  if (obj !== Object(obj)) {
    throw new TypeError('Object.keys called on a non-object');
  }
  var keys = [];
  var key = void 0;
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
}

function noop() {}



var fakeLogger = {
  markOnce: noop,
  mark: noop,
  markEnd: noop
};

// Copyright (C) 2014-present  SheetJS

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// modify by longjiawen@meituan.com

var T = signedCrcTable();

function signedCrcTable() {
  var c = 0;
  var table = new Array(256);

  for (var n = 0; n !== 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }

  return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

function crc32Str(str, seed) {
  var C = seed ^ -1;
  for (var i = 0, L = str.length, c, d; i < L;) {
    c = str.charCodeAt(i++);
    if (c < 0x80) {
      C = C >>> 8 ^ T[(C ^ c) & 0xFF];
    } else if (c < 0x800) {
      C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    } else if (c >= 0xD800 && c < 0xE000) {
      c = (c & 1023) + 64;d = str.charCodeAt(i++) & 1023;
      C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 0xFF];
    } else {
      C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 0xFF];
      C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 0xFF];
    }
  }
  return (C ^ -1) >>> 0;
}

var Chunk = function () {
  function Chunk(name, state, options) {
    classCallCheck(this, Chunk);

    this.type = '';
    this.name = name;
    this.state = state;
    this.options = options;
    this.store = options.store;
    this.logger = options.logger;
    this._updateAdapter = options.updateAdapter;
    this._content = '';
  }

  createClass(Chunk, [{
    key: 'load',
    value: function load() {
      return this.getContent().then(noop, function (e) {
        console.error(e);
        // 获取失败时跳过，在 render 中执行缺少 content, 会执行 JSONP fallback
      });
    }
  }, {
    key: 'check',
    value: function check() {
      // if state.checksum is not exist, just skip
      // 例如：外链资源
      if (typeof this.state.checksum === 'undefined') return true;

      this.logger.mark('check:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'chunkChecksum',
        size: Math.floor(this._content.length / 1024),
        originChecksum: this.state.checksum,
        reportCost: true
      });
      var checksum = crc32Str(this._content);
      var isMatch = checksum === this.state.checksum;
      this.logger.markEnd('check:' + this.cacheKey, {
        isMatch: isMatch,
        currentChecksum: checksum
      });

      if (isMatch) return isMatch;
      // if not match，call clear
      this.store.remove(this.cacheKey);
      return false;
    }
  }, {
    key: '_request',
    value: function _request$$1() {
      var _this = this;

      // read from HTTP
      return new Promise(function (resolve, reject) {
        request(_this.link, function (err, content) {
          if (err) {
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullFailure',
              reportCost: true
            });
            return reject(err);
          } else {
            _this._content = content;
            _this.store.add({
              name: _this.cacheKey,
              hash: _this.hash,
              cacheAge: _this.state.cacheAge || _this.options.cacheAge,
              content: _this._content,
              filename: _this.filename
            });
            _this.logger.markEnd('async:' + _this.cacheKey, {
              reason: 'updateFullSuccess',
              reportCost: true
            });
            resolve(content);
          }
        });
      });
    }
  }, {
    key: 'update',
    value: function update(cached) {
      var _this2 = this;

      return this._updateAdapter(this.name, {
        localChunk: cached,
        remoteChunk: this.state
      }).then(function (payload) {
        // diff failed or skiped
        if (!payload || !payload.content) return _this2._request();

        // diff success
        _this2._content = payload.content;
        _this2.store.add({
          name: _this2.cacheKey,
          hash: _this2.hash,
          cacheAge: _this2.state.cacheAge || _this2.options.cacheAge,
          content: _this2._content,
          filename: _this2.filename
        });
        return _this2._content;
      }, function (e) {
        // diff failed
        console.error(e);
        return _this2._request();
      });
    }
  }, {
    key: 'getContent',
    value: function getContent() {
      var _this3 = this;

      if (this._content) return Promise.resolve(this._content);
      this.logger.markOnce('request:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'request'
      });
      this.logger.mark('async:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reportCost: true
      });
      // read from CacheStore
      return this.store.get(this.cacheKey).then(function (cached) {
        // no cache
        // read from HTTP
        if (!cached) return _this3._request();

        // has local Cache
        var content = cached.content,
            hash = cached.hash;
        // version matched

        if (_this3.hash === hash) {
          _this3.logger.markEnd('async:' + _this3.cacheKey, {
            reason: _this3.store.type,
            reportCost: true
          });
          _this3._content = content;
          return Promise.resolve(_this3._content);
        } else {
          // version not matched, try update
          return _this3.update(cached);
        }
      });
    }
  }, {
    key: 'fallback',
    value: function fallback() {
      var _this4 = this;

      var execFallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModuleAsyncLoad;

      this.logger.mark('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: 'fallbackStart'
      });
      return new Promise(function (resolve, reject) {
        // fallback
        execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (err) {
          // success
          if (!err) {
            _this4.fallbackState = 'fallbackSuccessFrist';
            return resolve();
          }
          // try again fallback link
          execFallback(_this4.fallbackLink, _this4.type, _this4.attrs, function (reErr) {
            if (!reErr) {
              _this4.fallbackState = 'fallbackSuccessSecond';
              return resolve();
            }
            _this4.fallbackState = 'fallbackFailure';
            reject(reErr);
          });
        });
      });
    }
  }, {
    key: 'cacheKey',
    get: function get$$1() {
      return '<' + this.type + '>:' + this.name;
    }
  }, {
    key: 'hash',
    get: function get$$1() {
      return this.state.hash || this.filename || this.link;
    }
  }, {
    key: 'link',
    get: function get$$1() {
      if (this.state.link) {
        return this.state.link;
      } else {
        return this.options.config.publicPath + this.filename;
      }
    }
  }, {
    key: 'fallbackState',
    set: function set$$1(value) {
      this.logger.markEnd('fallback:' + this.cacheKey, {
        chunkName: this.cacheKey,
        channel: 'lx',
        reason: value
      });
    }
  }, {
    key: 'fallbackLink',
    get: function get$$1() {
      // if link exist (外链资源), use link
      if (this.state.link) {
        return this.state.link;
      } else {
        // if fallbackCDN doesn't exist, use publicPath instead
        return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename;
      }
    }
  }, {
    key: 'attrs',
    get: function get$$1() {
      return assign({
        'thunder-cache-key': this.cacheKey,
        'crossorigin': this.options.config.crossOriginLoading
      }, this.options.attrs, this.state.attrs);
    }
  }]);
  return Chunk;
}();

var JSStaticType = 'js';

var ScriptChunk = function (_Chunk) {
  inherits(ScriptChunk, _Chunk);

  function ScriptChunk(name, state, options) {
    classCallCheck(this, ScriptChunk);

    var _this = possibleConstructorReturn(this, (ScriptChunk.__proto__ || Object.getPrototypeOf(ScriptChunk)).call(this, name, state, options));

    _this.type = JSStaticType;
    return _this;
  }

  createClass(ScriptChunk, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(execModule(this._content, 'js', this.attrs)).then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      } else {
        // 1. 没有 _content, 加载失败
        // 2. checksum 校验和不匹配
        return this.fallback().then(function () {
          if (!_this2.state.runScript) return;
          execModule(_this2.state.runScript, 'js', _this2.attrs);
        });
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return JSStaticType;
    }
  }]);
  return ScriptChunk;
}(Chunk);

var CSSStaticType = 'css';

var StyleChunk = function (_Chunk) {
  inherits(StyleChunk, _Chunk);

  function StyleChunk(name, state, options) {
    classCallCheck(this, StyleChunk);

    var _this = possibleConstructorReturn(this, (StyleChunk.__proto__ || Object.getPrototypeOf(StyleChunk)).call(this, name, state, options));

    _this.type = CSSStaticType;
    return _this;
  }

  createClass(StyleChunk, [{
    key: 'render',


    /*
    * render
    * @param exec
    * @param execFallback
    */
    value: function render() {
      var exec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execModule;
      var execFallback = arguments[1];

      if (this._content && (this.options.config.checksum ? this.check() : true)) {
        return Promise.resolve(exec(this._content, 'css', this.attrs));
      } else {
        return this.fallback(execFallback);
      }
    }
  }, {
    key: 'filename',
    get: function get$$1() {
      return this.state.filename;
    }
  }], [{
    key: 'type',
    get: function get$$1() {
      return CSSStaticType;
    }
  }]);
  return StyleChunk;
}(Chunk);

var Thunder$1 = function () {
  function Thunder(state) {
    classCallCheck(this, Thunder);

    this.state = state;
    this.version = '2.3.7';
    this.running = true;
    this.type = 'tiny';
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : '';
    this._chunks = [];
    this.init();
  }

  createClass(Thunder, [{
    key: 'set',
    value: function set$$1() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          nonce = _ref.nonce,
          publicPath = _ref.publicPath,
          attrs = _ref.attrs,
          fallbackCDN = _ref.fallbackCDN;

      if (nonce) this._chunkOptions.attrs.nonce = nonce;
      if (attrs) assign(this._chunkOptions.attrs, attrs);
      if (publicPath) this._chunkOptions.config.publicPath = publicPath;
      if (fallbackCDN) this._chunkOptions.config.fallbackCDN = fallbackCDN;
    }
  }, {
    key: 'init',
    value: function init() {
      var _this = this;

      if (isBrowser) {
        window.__thunder__ = this;
      }
      Thunder._installedPlugins.forEach(function (plugin) {
        return plugin(_this);
      });
      if (!this.logger) this.logger = fakeLogger;
      this._chunkOptions = {
        attrs: assign({}, this.state.outputOptions.attrs),
        config: this.state.outputOptions,
        cacheAge: this.state.cacheAge,
        store: this.store,
        logger: this.logger,
        updateAdapter: this.updateAdapter.bind(this)
        // match resource
        // js -> create scriptChunk instance
        // css -> create styleChunk instance
      };this.state.resources.forEach(function (resource) {
        Thunder.Chunks.forEach(function (ChunkConstructor) {
          if (resource.type !== ChunkConstructor.type) return;
          _this._chunks.push(new ChunkConstructor(resource.name, resource, _this._chunkOptions));
        });
      });
      // prepare clear unexist chunk cache
      this.store.saveChunksMap(this._chunks.map(function (c) {
        return c.cacheKey;
      }));

      this.logger.markOnce('init', {
        channel: 'lx',
        SWSupport: this.serviceWorkerManager && this.serviceWorkerManager.isSupport(),
        useSW: !!this.state.serviceWorker,
        reason: 'init'
      });
    }
  }, {
    key: 'updateAdapter',
    value: function updateAdapter(chunkName, preUpdateData) {
      if (!this._updateAdapter) return Promise.resolve();
      return this._updateAdapter(chunkName, preUpdateData, this, {
        Promise: Promise,
        request: request,
        debug: debug,
        logger: this.logger
      });
    }
  }, {
    key: 'bundleLoader',
    value: function bundleLoader(chunkName) {
      return this.parallel(chunkName);
    }
  }, {
    key: 'styleLoader',
    value: function styleLoader(chunkName) {
      return this.parallelStyle(chunkName);
    }
  }, {
    key: 'parallelStyle',
    value: function parallelStyle(chunkNames) {
      return this.parallel(chunkNames, 'css');
    }
  }, {
    key: 'load',
    value: function load(jobs, cb) {
      var _this2 = this;

      var queue = Promise.resolve();
      // load
      jobs.forEach(function (job) {
        job.action = job.action || 'load';
        if (job.action === 'load') {
          queue = queue.then(function () {
            return _this2.parallel(job.chunks, job.type);
          });
        }
      });
      // prefetch
      jobs.forEach(function (job) {
        if (job.action === 'prefetch') {
          queue = queue.then(function () {
            return _this2.prefetch(job.chunks, job.type);
          });
        }
      });
      queue.then(function () {
        if (cb) cb();
      });
      return queue;
    }
  }, {
    key: 'parallel',
    value: function parallel(chunkNames, type) {
      var chunks = this._getChunks(chunkNames, type);

      return Promise.all(chunks.map(function (c) {
        return c.load();
      })).then(function () {
        var queue = Promise.resolve();
        chunks.forEach(function (c) {
          queue = queue.then(function () {
            return c.render();
          });
        });
        return queue;
      }).catch(function (err) {
        return console.error(err);
      });
    }
  }, {
    key: 'prefetch',
    value: function prefetch() {
      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // delay 500ms
      var prefetchChunks = this._getChunks(chunks);
      prefetchChunks = prefetchChunks.concat(this._getChunks(chunks, 'css'));
      return new Promise(function (resolve, reject) {
        setTimeout(resolve, 500);
      }).then(function () {
        var unloadChunks = [];
        prefetchChunks.map(function (c) {
          if (!c._content) unloadChunks.push(c);
        });
        return Promise.all(unloadChunks.map(function (c) {
          return c.getContent();
        }));
      });
    }

    /*
    * @internal
    * _getChunks
    * @param chunkNames <String> Array or String
    * @param type String
    * @return <Chunk> Array
    */

  }, {
    key: '_getChunks',
    value: function _getChunks(_chunkNames) {
      var _this3 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'js';

      var chunkNames = void 0;
      var chunks = [];

      if (typeof _chunkNames === 'string') {
        chunkNames = [_chunkNames];
      } else {
        chunkNames = _chunkNames;
      }

      chunkNames.forEach(function (name) {
        _this3._chunks.forEach(function (c) {
          if (c.type === type && name === c.name) {
            chunks.push(c);
          }
        });
      });

      return chunks;
    }
  }]);
  return Thunder;
}();

Thunder$1.StyleChunk = StyleChunk;
Thunder$1.ScriptChunk = ScriptChunk;
Thunder$1.BaseChunk = Chunk;
Thunder$1.Chunks = [StyleChunk, ScriptChunk];

Thunder$1._installedPlugins = [];

Thunder$1.use = function use() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var plugin = args.shift();
  var installedPlugins = this._installedPlugins;
  if (!plugin || installedPlugins.indexOf(plugin) > -1) {
    return this;
  }
  // args.unshift(this)
  // if (typeof plugin.install === 'function') {
  //   plugin.install.apply(plugin, args)
  // } else if (typeof plugin === 'function') {
  //   plugin.apply(null, args)
  // }
  installedPlugins.push(plugin);
  return this;
};

var supportPerformance = isBrowser && 'performance' in window && 'now' in performance;

function getRandomInt() {
  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;

  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function fakeId() {
  var i = 16;
  var id = '';
  while (i--) {
    id += '' + getRandomInt();
  }
  return id;
}

function timeNow() {
  if (supportPerformance) return performance.now();
  return Date.now();
}

var LXReporter = function () {
  function LXReporter() {
    classCallCheck(this, LXReporter);

    this.logQueue = [];
    this._timer = null;
    this._delay = 100;
    this._url = '//report.meituan.com';
    this.report = this.report.bind(this);
  }

  createClass(LXReporter, [{
    key: '_report',
    value: function _report() {
      var _this = this;

      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

      var msid = fakeId();
      var uuid = fakeId();
      var lxCuid = document.cookie.replace(/(?:(?:^|.*;\s*)_lxsdk_cuid\s*=\s*([^;]*).*$)|^.*$/, '$1');

      var logs = this.logQueue.map(function (data) {
        var seq = fakeId().slice(0, 4);
        var reqId = fakeId();

        // 增加灵犀 trace id 上报
        data.lxid = lxCuid;

        return {
          'req_id': reqId,
          'val_cid': data.cid ? data.cid : 'c_c4nzgz77',
          'nt': 0,
          'isauto': 7,
          'tm': data.createdAt,
          'val_lab': data,
          'val_bid': data.bid || 'b_w006udto',
          'seq': +seq,
          'nm': 'MV'
        };
      });

      return request({
        url: this._url,
        method: 'post',
        data: [{
          'category': 'data_sdk_smartpay',
          'sdk_ver': '4.3.0',
          'ct': 'www',
          'ch': 'web',
          'ua': navigator && navigator.userAgent,
          'sc': '640*360',
          'uuid': uuid,
          'lxid': lxCuid,
          'msid': msid,
          'appnm': 'qrcode_pay_fe',
          'evs': logs
        }]
      }).then(function () {
        _this.logQueue.length = 0;
        fn();
      }).catch(function (err) {
        if (err) console.log(err);
        fn(err);
      });
    }
  }, {
    key: 'report',
    value: function report(data, fn) {
      var _this2 = this;

      data.createdAt = Date.now();
      this.logQueue.push(data);
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(function () {
        _this2._timer = null;
        _this2._report(fn);
      }, this._delay);
    }
  }]);
  return LXReporter;
}();

var lxReporter = new LXReporter();

// import owl from './owl-report'

var Logger = function () {
  function Logger(_ref) {
    var project = _ref.project,
        version = _ref.version,
        starkAppKey = _ref.starkAppKey;
    classCallCheck(this, Logger);

    this.project = project;
    this.version = version;
    this.starkAppKey = starkAppKey;
    this.logQueue = [];
    this.markQueue = {};
    this._reporters = [{
      reporter: lxReporter.report,
      channel: 'lx'
    }];
    this._timer = null;
  }

  createClass(Logger, [{
    key: 'use',
    value: function use(fn, channel) {
      if (typeof fn !== 'function') return;
      var has = false;
      this._reporters.map(function (ctx) {
        if (ctx.reporter === fn) has = true;
      });
      if (!has) {
        this._reporters.push({
          channel: channel,
          reporter: fn
        });
      }
    }
  }, {
    key: 'mark',
    value: function mark(key) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!key) return;
      this.markQueue[key] = {
        createdAt: timeNow(),
        data: data
      };
    }
  }, {
    key: 'markEnd',
    value: function markEnd(key, data, noInject) {
      var mark = this.markQueue[key];
      if (!mark) return;
      var now = timeNow();
      var cost = now - mark.createdAt;
      var log = {
        key: key,
        data: assign(noInject ? {} : {
          project: this.project,
          starkAppKey: this.starkAppKey,
          cost: cost,
          name: key,
          version: this.version
        }, mark.data, data)
      };

      if (log.error) {
        return console.log(log.err);
      }

      if (log.data.cost) {
        log.data.cost = Math.floor(log.data.cost);
      }

      this.logQueue.push(log);
      delete this.markQueue[key];
      this.report();
    }
  }, {
    key: 'markOnce',
    value: function markOnce(key, data, noInject) {
      this.mark(key, data);
      this.markEnd(key, data, noInject);
    }
  }, {
    key: 'report',
    value: function report() {
      if (this._timer) clearTimeout(this._timer);
      this._timer = setTimeout(this._report.bind(this), 300);
    }
  }, {
    key: '_report',
    value: function _report() {
      var _this = this;

      this._timer = null;
      this.logQueue.forEach(function (log) {
        if (!log.data) return;
        _this._reporters.forEach(function (ctx) {
          if (log.data.channel) {
            if (ctx.channel === log.data.channel) {
              ctx.reporter(log.data);
            }
          } else {
            ctx.reporter(log.data);
          }
        });
      });

      this.logQueue.length = 0;
    }
  }]);
  return Logger;
}();

var Logger$1 = (function (thunder) {
  thunder.logger = new Logger({
    version: thunder.version,
    project: thunder.state.project,
    starkAppKey: thunder.starkAppKey
  });
});

var THUNDER_KEY = 'Thunder';

var LSStorage = function () {
  function LSStorage(_ref) {
    var version = _ref.version,
        _ref$project = _ref.project,
        project = _ref$project === undefined ? '' : _ref$project;
    classCallCheck(this, LSStorage);

    this.type = 'LSCache';
    this.prefix = THUNDER_KEY + '#' + project;
    this._storekey = this.prefix + ':store';
    this.storage = supportLS && window.localStorage;
    this.state = {
      size: 0,
      count: 0,
      version: version,
      cacheMap: {},
      chunks: []
    };
    this._delay = 100;
    this._saveTimer = null;
    this._load();
  }

  createClass(LSStorage, [{
    key: '_save',
    value: function _save() {
      var _this = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._delay;

      if (!supportLS) return;
      var job = function job() {
        var stateRaw = JSON.stringify(_this.state);
        try {
          _this.storage.setItem(_this._storekey, stateRaw);
        } catch (e) {
          _this.clear();
          debug('error', e);
        }
      };
      if (delay === 0) {
        return job();
      }
      if (this._saveTimer) clearTimeout(this._saveTimer);
      this._saveTimer = setTimeout(function () {
        job();
      }, delay);
    }
  }, {
    key: '_load',
    value: function _load() {
      if (!supportLS) return;
      try {
        this.storage.setItem(THUNDER_KEY + '?v', this.state.version);
        var stateRaw = this.storage.getItem(this._storekey);
        if (!stateRaw) return;
        var state = JSON.parse(stateRaw);
        if (this._schemaCheck(state)) {
          this.state = state;
        }
      } catch (e) {
        this.clear();
        debug('error', e);
      }
    }
  }, {
    key: '_schemaCheck',
    value: function _schemaCheck(state) {
      var _this2 = this;

      var seem = true;
      var toString = Object.prototype.toString;
      keys(this.state).forEach(function (key) {
        if (!seem) return;
        seem = toString.call(state[key]) === toString.call(_this2.state[key]);
      });
      keys(state).forEach(function (key) {
        if (_this2.state[key] === undefined) {
          seem = false;
        }
      });
      return seem;
    }
  }, {
    key: '_getChunkName',
    value: function _getChunkName(chunkName) {
      return this.prefix + '~' + chunkName;
    }
  }, {
    key: '_updateStateInfo',
    value: function _updateStateInfo() {
      var _this3 = this;

      var size = 0;
      var count = 0;

      keys(this.state.cacheMap).forEach(function (key) {
        size += _this3.state.cacheMap[key].size || 0;
        count++;
      });

      this.state.size = size;
      this.state.count = count;
    }
  }, {
    key: 'saveChunksMap',
    value: function saveChunksMap(chunks) {
      this.state.chunks = chunks;
      this._save(0);
      this.clearAbandonedChunkCache(chunks);
    }

    /*
    * clearAbandonedChunkCache
    */

  }, {
    key: 'clearAbandonedChunkCache',
    value: function clearAbandonedChunkCache(chunks) {
      var _this4 = this;

      if (!supportLS) return;
      var cacheContentPrefix = this.prefix + '~';
      var preReg = new RegExp(cacheContentPrefix);
      var contentKeys = [];

      keys(this.storage).forEach(function (cacheKey) {
        if (preReg.test(cacheKey)) {
          contentKeys.push(cacheKey.replace(cacheContentPrefix, ''));
        }
      });

      contentKeys.forEach(function (cacheKey) {
        if (chunks.indexOf(cacheKey) === -1) {
          _this4.remove(cacheKey);
        }
      });
    }

    /*
      * get
      * @param url : String
      * @return Object or null
      */

  }, {
    key: '_get',
    value: function _get(name) {
      if (!supportLS) return null;
      var content = this.storage.getItem(this._getChunkName(name));
      var cacheData = this.state.cacheMap[name];

      // check exist
      if (!content || !cacheData) {
        this.remove(name);
        return null;
      }

      // check expire
      if (cacheData.expireAt) {
        var now = Date.now();
        if (cacheData.expireAt < now) return null;
      }

      return _extends({}, cacheData, {
        content: content
      });
    }

    /*
      * get
      * @param url : String
      * @return Object or null
      */

  }, {
    key: 'get',
    value: function get$$1(name) {
      return Promise.resolve(this._get(name));
    }

    /*
      * add
      * @param url : String
      * @param content : String
      * @return Boolean
      */

  }, {
    key: 'add',
    value: function add(payload) {
      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!supportLS) return false;
      try {
        var name = payload.name,
            hash = payload.hash,
            content = payload.content,
            filename = payload.filename,
            cacheAge = payload.cacheAge;

        this.storage.setItem(this._getChunkName(name), content);

        var now = Date.now();
        var expireAt = 0;

        if (cacheAge) {
          expireAt = now + cacheAge * 1000;
        }

        this.state.cacheMap[name] = {
          loadedAt: now,
          size: Math.round(content.length / 1024),
          hash: hash,
          expireAt: expireAt,
          filename: filename
        };

        this._updateStateInfo();

        this._save();

        return Promise.resolve(true);
      } catch (e) {
        if (retry) {
          this.retryAdd(payload, 3);
        }
        return Promise.resolve(false);
      }
    }
  }, {
    key: 'retryAdd',
    value: function retryAdd(payload, tryCount) {
      if (!tryCount) return debug('retry add failed  ' + payload.name + ' is too large: ' + Math.floor(payload.content.length / 1024) + ' KB');
      tryCount--;
      this.free();
      // when add failed try once
      if (!this.add(payload, false)) {
        this.retryAdd(payload, tryCount);
      } else {
        debug('retry add success', tryCount);
      }
    }

    /*
    * free
    * remove oldest chunk cache for ls
    */

  }, {
    key: 'free',
    value: function free() {
      var _this5 = this;

      var chunk = void 0;
      var chunkList = keys(this.state.cacheMap).map(function (chunkName) {
        chunk = _this5.state.cacheMap[chunkName];
        return {
          name: chunkName,
          // size: chunk.size,
          loadedAt: chunk.loadedAt
        };
      }).sort(function (a, b) {
        return a.loadedAt - b.loadedAt;
      });
      if (!chunkList.length) return;
      this.remove(chunkList[0].name);
    }
  }, {
    key: 'clear',
    value: function clear() {
      var _this6 = this;

      keys(this.state.cacheMap).forEach(function (chunkName) {
        _this6.remove(chunkName);
      });
    }
  }, {
    key: 'remove',
    value: function remove(chunkName) {
      if (!supportLS) return;
      var cache = this.state.cacheMap[chunkName];

      if (cache) {
        delete this.state.cacheMap[chunkName];
        this._updateStateInfo();
      }

      this.storage.removeItem(this._getChunkName(chunkName));
      this._save();
    }
  }]);
  return LSStorage;
}();

var Store = (function (thunder) {
  thunder.store = new LSStorage({
    project: thunder.starkAppKey || thunder.state.project,
    version: thunder.version
  });
});

var CheckInBrowser = typeof window !== 'undefined';
var SupportPerformance = CheckInBrowser && 'performance' in window && 'now' in performance;

function timeNow$1() {
  if (SupportPerformance) return Math.floor(performance.now());
  return Date.now();
}

var DEFAULT_ADDRESS = 'https://jarvas-static.meituan.net/diff/';
var DEFAULT_FALLBACK = '//jarvas-static.meituan.net/file/PROJECT_NAME?filePath=';

var STARK_DIFF_STATUS = {
  PATCH: 2,
  FULL: 1,
  FAILED: 0
};
var STARK_DIFF_CODE = {
  CLIENT_PATCH_ERROR: 416,
  CHECKSUM_FAILED: 409,
  UNKNOWN_ERROR: 400,
  LOCAL_VERSION_NOT_FOUND: 205
};

function StarkError(message, code, result) {
  this.message = message;
  this.statusCode = code;
  this.result = result || {};
}

StarkError.prototype = new Error();
StarkError.prototype.constructor = StarkError;

/**
* recoverMin
* @param {string} source         LS中的缓存源文件
* @param {string} patchContent   Stark服务器返回的patch文件
* @return {Object} content: 新文件内容, fullLength全量大小, patchLength补丁大小
*/
function recoverMin() {
  var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var patchContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var units = patchContent.split('\t');
  var content = source;
  var pos = 0;

  var start = timeNow$1();

  for (var i = 0; i < units.length; i++) {
    var command = units[i][0];
    if (command === '=') {
      pos += parseInt(units[i].slice(1), 10);
    } else if (command === '-') {
      var length = parseInt(units[i].slice(1), 10);
      content = content.slice(0, pos) + content.slice(pos + length);
    } else if (command === '+') {
      var newPartial = decodeURI(units[i].slice(1));
      content = content.slice(0, pos) + newPartial + content.slice(pos);
      pos += newPartial.length;
    } else {
      throw new StarkError('Broken patch found', STARK_DIFF_CODE.CLIENT_PATCH_ERROR);
    }
  }

  return {
    content: content,
    fullLength: content.length,
    patchLength: patchContent.length,
    recoverCost: timeNow$1() - start
  };
}

function handleResponse(responseText, source) {
  var patchJson = JSON.parse(responseText);
  var result = void 0;

  if (patchJson.status === STARK_DIFF_STATUS.FAILED) {
    throw new StarkError('Stark service down', patchJson.code);
  }
  if (patchJson.status === STARK_DIFF_STATUS.FULL) {
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: patchJson.content,
      fullLength: patchJson.content.length,
      patchLength: patchJson.content.length,
      checksum: patchJson.newFileChecksum
    };
  }
  if (patchJson.status === STARK_DIFF_STATUS.PATCH) {
    var recoverResult = recoverMin(source, patchJson.content);
    result = {
      status: patchJson.status,
      statusCode: patchJson.code,
      content: recoverResult.content,
      fullLength: recoverResult.fullLength,
      patchLength: recoverResult.patchLength,
      checksum: patchJson.newFileChecksum
    };
  }

  return result;
}

function genStarkLink(chunkName, localChunk, remoteChunk) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var address = options.address,
      projectName = options.projectName;

  var realAddress = address || DEFAULT_ADDRESS;

  if (!localChunk || !localChunk.hash) {
    return;
  }

  var oldFilePath = localChunk.filename;
  var newFilePath = remoteChunk.filename;

  var oldFilePathParam = encodeURIComponent(oldFilePath);
  var newFilePathParam = encodeURIComponent(newFilePath);

  return '' + realAddress + projectName + '?oldFilePath=' + oldFilePathParam + '&newFilePath=' + newFilePathParam;
}

var StarkUpdatePlugin = function () {
  function StarkUpdatePlugin(chunkName, _ref, options, helpers) {
    var localChunk = _ref.localChunk,
        remoteChunk = _ref.remoteChunk;
    classCallCheck(this, StarkUpdatePlugin);

    this.chunkName = chunkName;
    this.localChunk = localChunk || {};
    this.remoteChunk = remoteChunk;
    this.options = options;
    this.helpers = helpers;
  }

  createClass(StarkUpdatePlugin, [{
    key: 'report',
    value: function report(_ref2, result) {
      var status = _ref2.status,
          statusCode = _ref2.statusCode,
          loadCost = _ref2.loadCost;

      var chunkName = this.chunkName;
      var localChunk = this.localChunk;
      var remoteHash = this.remoteChunk.hash || this.remoteChunk.filename;

      this.helpers.logger.markOnce('stark:' + chunkName, {
        channel: 'lx',
        appKey: this.options.projectName, // 项目key,即管理系统生成的项目appkey
        fileName: chunkName, // 文件名字
        currentVersion: localChunk.hash, // 当前资源版本
        diffVersion: remoteHash, // 需要diff的版本
        saveSize: Math.max(result.fullLength - result.patchLength, 0), // diff节省的流量
        diffState: status,
        diffDetailState: statusCode,
        patchLength: result.patchLength,
        fullLength: result.fullLength,
        recoverCost: result.recoverCost,
        loadCost: loadCost, // 补丁请求时间
        checksum: result.checksum
      }, false);
    }
  }, {
    key: 'getDiff',
    value: function getDiff() {
      var _this = this;

      var chunkName = this.chunkName;
      var localChunk = this.localChunk;
      var remoteHash = this.remoteChunk.hash;
      var link = genStarkLink(chunkName, this.localChunk, this.remoteChunk, this.options);

      if (!localChunk || !localChunk.filename || !localChunk.content) return this.helpers.Promise.resolve();
      var start = timeNow$1();
      return this.helpers.request(link).then(function (responseText) {
        var result = handleResponse(responseText, localChunk.content);

        var status = result.status,
            statusCode = result.statusCode,
            content = result.content;


        _this.report({
          status: status,
          statusCode: statusCode,
          loadCost: timeNow$1() - start
        }, result);

        return content;
      }).then(function (content) {
        return {
          name: chunkName,
          content: content,
          hash: remoteHash,
          from: 'diff'
        };
      }, function (err) {
        _this.helpers.debug('error', 'getDiff failed', err);
        var statusCode = void 0;
        if (!localChunk.hash) {
          statusCode = STARK_DIFF_CODE.LOCAL_VERSION_NOT_FOUND;
        } else {
          statusCode = err.statusCode || STARK_DIFF_CODE.UNKNOWN_ERROR;
        }

        var result = err && err.result || {};

        _this.report({
          status: STARK_DIFF_STATUS.FAILED,
          statusCode: statusCode
        }, result);

        return _this.helpers.Promise.resolve();
      });
    }
  }]);
  return StarkUpdatePlugin;
}();

function StarkUpdate(chunkName, chunkData, thunder, helpers) {
  if (!thunder.state.StarkOptions) return helpers.Promise.resolve();
  var _thunder$state$StarkO = thunder.state.StarkOptions,
      projectName = _thunder$state$StarkO.projectName,
      fallback = _thunder$state$StarkO.fallback;

  var realFallback = fallback || DEFAULT_FALLBACK.replace('PROJECT_NAME', projectName);

  thunder.set({
    fallbackCDN: realFallback
  });
  var starkUpdator = new StarkUpdatePlugin(chunkName, chunkData, thunder.state.StarkOptions, helpers);
  return starkUpdator.getDiff();
}

function install(Thunder) {
  Thunder.prototype._updateAdapter = StarkUpdate;
}

// 暴露 Promise polyfill
window.Promise = Promise$1;

Thunder$1.use(Logger$1).use(Store).use(function () {
  return install(Thunder$1);
});

return Thunder$1;

})));
