import { isBrowser, debug } from '../util'
import Emitter from '../event'

// getRegistrations : chrome 45
// onmessage : chrome 40
const SUPPORT_SERVICE_WORKER = Boolean(isBrowser &&
  ('serviceWorker' in navigator) &&
  ('onmessage' in navigator.serviceWorker)
)
const SUPPORT_CACHE = isBrowser && ('caches' in window)
const SUPPORT_MESSAGE_CHANNEL = isBrowser && ('MessageChannel' in window)
// localhost
// [::1] is the IPv6 localhost address.
// 127.0.0.1/8 is considered localhost for IPv4.
const IN_LOCALHOST = Boolean(isBrowser &&
  (
    window.location.hostname === 'localhost' ||
    window.location.hostname === '[::1]' ||
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
    )
  )
)
const IN_HTTPS = Boolean(isBrowser && window.location.protocol === 'https:')
const SW_EVENT_PREFIX_REG = /^thunder:sw-event:/i
const THUNDER_CACHE_NAME_PRE = /\$\$\$thunder-serviceworker/

export default class ServiceWorkerManager extends Emitter {
  constructor (state, helpers) {
    super()
    this.state = state
    this.options = state.serviceWorker
    this.serviceWorker = null
    this.logger = helpers.logger
    this.cache = this.initCache()
    this.ready = this._ready()
  }

  static isSupport () {
    return ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER && (ServiceWorkerManager.env.IN_HTTPS || ServiceWorkerManager.env.IN_LOCALHOST)
  }

  isSupport () {
    return ServiceWorkerManager.isSupport()
  }

  get active () {
    if (!ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER) return false
    if (!navigator.serviceWorker.controller) return false
    return navigator.serviceWorker.controller.state === 'activated'
  }

  static unregister () {
    /* Secure Origin issue
        * Secure origins
        * (https, *, *)
        * (wss, *, *)
        * (*, localhost, *)
        * (*, 127/8, *)
        * (*, ::1/128, *)
        * (file, *, —)
        * (chrome-extension, *, —)
        */
    if (ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER && ServiceWorkerManager.env.SUPPORT_CACHE && caches.keys) {
      caches.keys()
        .then(keys => {
          keys.forEach(key => {
            if (ServiceWorkerManager.env.THUNDER_CACHE_NAME_PRE.test(key)) {
              caches.delete(key)
              debug('cache cleard')
            }
          })
        })
        .catch(err => {
          debug('error', 'unregister', err)
        })
    }
    if (ServiceWorkerManager.env.SUPPORT_SERVICE_WORKER) {
      // chrome 40, single
      if (navigator.serviceWorker.getRegistration) {
        navigator.serviceWorker.getRegistration()
          .then(registration => {
            if (!registration) return
            registration.unregister()
            debug('sw unregisted')
          })
          .catch(err => {
            debug('error', 'unregister', err)
          })
      }
      if (navigator.serviceWorker.getRegistrations) {
        navigator.serviceWorker.getRegistrations()
          .then(registrations => {
            registrations.forEach(registration => {
              registration.unregister()
            })
            debug('sw unregisted')
          })
          .catch(err => {
            debug('error', 'unregister', err)
          })
      }
    }
  }

  _ready () {
    if (!ServiceWorkerManager.isSupport()) {
      // return Promise.reject(new Error('current env not support service-worker'))
      return Promise.resolve()
    }
    if (!this.options) {
      ServiceWorkerManager.unregister()
      // return Promise.reject(new Error('did\'t provide serviceWorker options'))
      return Promise.resolve()
    }
    navigator.serviceWorker.onmessage = this.onMessage.bind(this)
    return this._register()
      .then(sw => {
        this.serviceWorker = sw
        this.sendMessage({
          command: 'update:ua',
          userAgent: window.navigator.userAgent
        })
        this.report()
        return sw
      })
  }

  _register () {
    return navigator.serviceWorker.register(this.options.path + '?v=' + this.state.compilation.hash, {
      scope: this.options.scope
    })
      .then(reg => {
        // installing
        // waiting
        // active
        if (reg.active) return reg.active
        return new Promise((resolve, reject) => {
          reg.addEventListener('updatefound', () => {
            const newWorker = reg.installing

            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'activated') {
                resolve(newWorker)
              }
            })
          })
        })
      })
  }

  report () {
    this.sendMessage({ command: 'log' })
      .then(res => {
        if (!res.data && !(res.data instanceof Array)) return
        const logs = res.data
        logs.forEach(log => {
          this.logger.markOnce('sw:cachedFetch', {
            channel: 'lx',
            reason: 'swCache',
            ...log.data,
            url: log.key
          })
        })
      })
      .catch((e) => {
        this.logger.markOnce('swInitError', {
          channel: 'lx',
          reason: 'swInitError',
          message: e && e.message,
          stack: e & e.toString()
        })
        debug('warn', e)
      })
  }

  initCache () {
    return {
      keys: () => {
        return this.sendMessage({ command: 'cache:keys' })
      },
      clear: () => {
        return this.sendMessage({ command: 'cache:clear' })
      },
      add: (url) => {
        return this.sendMessage({ command: 'cache:add', url: url })
      },
      delete: (url) => {
        return this.sendMessage({ command: 'cache:delete', url: url })
      }
    }
  }

  sendMessage (message) {
    return this.ready.then(() => new Promise((resolve, reject) => {
      if (!this.serviceWorker) return reject(new Error('service-worker not ready'))
      if (!ServiceWorkerManager.env.SUPPORT_MESSAGE_CHANNEL) return reject(new Error('unsupport MessageChannel'))
      const channel = new MessageChannel()
      channel.port1.onmessage = function (event) {
        if (event.data.error) {
          reject(event.data.error)
        } else {
          resolve(event.data)
        }
      }
      this.serviceWorker.postMessage(message, [channel.port2])
    }))
  }

  onMessage (e) {
    if (!e.data && e.data instanceof Object) return
    const data = e.data
    const type = data.type || ''
    if (ServiceWorkerManager.env.SW_EVENT_PREFIX_REG.test(type)) {
      const eventType = type.replace(ServiceWorkerManager.env.SW_EVENT_PREFIX_REG, '')
      this.$emit(eventType, data)
    }
  }
}

ServiceWorkerManager.env = {
  THUNDER_CACHE_NAME_PRE,
  SW_EVENT_PREFIX_REG,
  IN_HTTPS,
  IN_LOCALHOST,
  SUPPORT_MESSAGE_CHANNEL,
  SUPPORT_CACHE,
  SUPPORT_SERVICE_WORKER
}
