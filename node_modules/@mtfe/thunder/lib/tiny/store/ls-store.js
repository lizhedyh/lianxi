import {
  debug,
  supportLS,
  keys
} from '../util'

const THUNDER_KEY = 'Thunder'

export class LSStorage {
  constructor ({ version, project = '' }) {
    this.type = 'LSCache'
    this.prefix = THUNDER_KEY + '#' + project
    this._storekey = this.prefix + ':store'
    this.storage = supportLS && window.localStorage
    this.state = {
      size: 0,
      count: 0,
      version: version,
      cacheMap: {},
      chunks: []
    }
    this._delay = 100
    this._saveTimer = null
    this._load()
  }

  _save (delay = this._delay) {
    if (!supportLS) return
    const job = () => {
      const stateRaw = JSON.stringify(this.state)
      try {
        this.storage.setItem(this._storekey, stateRaw)
      } catch (e) {
        this.clear()
        debug('error', e)
      }
    }
    if (delay === 0) {
      return job()
    }
    if (this._saveTimer) clearTimeout(this._saveTimer)
    this._saveTimer = setTimeout(() => {
      job()
    }, delay)
  }

  _load () {
    if (!supportLS) return
    try {
      this.storage.setItem(THUNDER_KEY + '?v', this.state.version)
      const stateRaw = this.storage.getItem(this._storekey)
      if (!stateRaw) return
      const state = JSON.parse(stateRaw)
      if (this._schemaCheck(state)) {
        this.state = state
      }
    } catch (e) {
      this.clear()
      debug('error', e)
    }
  }

  _schemaCheck (state) {
    let seem = true
    const toString = Object.prototype.toString
    keys(this.state).forEach(key => {
      if (!seem) return
      seem = toString.call(state[key]) === toString.call(this.state[key])
    })
    keys(state).forEach(key => {
      if (this.state[key] === undefined) {
        seem = false
      }
    })
    return seem
  }

  _getChunkName (chunkName) {
    return this.prefix + '~' + chunkName
  }

  _updateStateInfo () {
    let size = 0
    let count = 0

    keys(this.state.cacheMap).forEach(key => {
      size += this.state.cacheMap[key].size || 0
      count++
    })

    this.state.size = size
    this.state.count = count
  }

  saveChunksMap (chunks) {
    this.state.chunks = chunks
    this._save(0)
    this.clearAbandonedChunkCache(chunks)
  }

  /*
  * clearAbandonedChunkCache
  */
  clearAbandonedChunkCache (chunks) {
    if (!supportLS) return
    const cacheContentPrefix = this.prefix + '~'
    const preReg = new RegExp(cacheContentPrefix)
    const contentKeys = []

    keys(this.storage).forEach(cacheKey => {
      if (preReg.test(cacheKey)) {
        contentKeys.push(cacheKey.replace(cacheContentPrefix, ''))
      }
    })

    contentKeys.forEach(cacheKey => {
      if (chunks.indexOf(cacheKey) === -1) {
        this.remove(cacheKey)
      }
    })
  }

  /*
    * get
    * @param url : String
    * @return Object or null
    */
  _get (name) {
    if (!supportLS) return null
    const content = this.storage.getItem(this._getChunkName(name))
    const cacheData = this.state.cacheMap[name]

    // check exist
    if (!content || !cacheData) {
      this.remove(name)
      return null
    }

    // check expire
    if (cacheData.expireAt) {
      const now = Date.now()
      if (cacheData.expireAt < now) return null
    }

    return {
      ...cacheData,
      content: content
    }
  }

  /*
    * get
    * @param url : String
    * @return Object or null
    */
  get (name) {
    return Promise.resolve(this._get(name))
  }

  /*
    * add
    * @param url : String
    * @param content : String
    * @return Boolean
    */
  add (payload, retry = true) {
    if (!supportLS) return false
    try {
      const { name, hash, content, filename, cacheAge } = payload
      this.storage.setItem(this._getChunkName(name), content)

      const now = Date.now()
      let expireAt = 0

      if (cacheAge) {
        expireAt = now + cacheAge * 1000
      }

      this.state.cacheMap[name] = {
        loadedAt: now,
        size: Math.round(content.length / 1024),
        hash: hash,
        expireAt: expireAt,
        filename: filename
      }

      this._updateStateInfo()

      this._save()

      return Promise.resolve(true)
    } catch (e) {
      if (retry) {
        this.retryAdd(payload, 3)
      }
      return Promise.resolve(false)
    }
  }

  retryAdd (payload, tryCount) {
    if (!tryCount) return debug(`retry add failed  ${payload.name} is too large: ${Math.floor((payload.content.length / 1024))} KB`)
    tryCount--
    this.free()
    // when add failed try once
    if (!this.add(payload, false)) {
      this.retryAdd(payload, tryCount)
    } else {
      debug('retry add success', tryCount)
    }
  }

  /*
  * free
  * remove oldest chunk cache for ls
  */
  free () {
    let chunk
    const chunkList = keys(this.state.cacheMap)
      .map(chunkName => {
        chunk = this.state.cacheMap[chunkName]
        return {
          name: chunkName,
          // size: chunk.size,
          loadedAt: chunk.loadedAt
        }
      })
      .sort((a, b) => {
        return a.loadedAt - b.loadedAt
      })
    if (!chunkList.length) return
    this.remove(chunkList[0].name)
  }

  clear () {
    keys(this.state.cacheMap).forEach(chunkName => {
      this.remove(chunkName)
    })
  }

  remove (chunkName) {
    if (!supportLS) return
    let cache = this.state.cacheMap[chunkName]

    if (cache) {
      delete this.state.cacheMap[chunkName]
      this._updateStateInfo()
    }

    this.storage.removeItem(this._getChunkName(chunkName))
    this._save()
  }
}

export default thunder => {
  thunder.store = new LSStorage({
    project: thunder.starkAppKey || thunder.state.project,
    version: thunder.version
  })
}
