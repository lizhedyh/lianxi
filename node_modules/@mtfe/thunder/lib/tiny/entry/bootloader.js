import {
  assign,
  isBrowser,
  supportLS,
  noop
} from '../util'
import {
  Chunk
} from '../chunk/bootloader'

class BootLogger {
  constructor (options) {
    this.options = options
    this._logQueue = []
    this._logger = null
  }

  set (logger) {
    this._logger = logger
    this.send()
  }

  send () {
    if (!this._logger) return
    this._logger.logQueue = this._logger.logQueue.concat(this._logQueue)
    this._logQueue.length = 0
    this._logger.report()
  }

  markOnce (key, data) {
    const log = {
      key,
      data: assign({
        channel: 'lx',
        from: 'bootloader',
        version: this.options.version,
        project: this.options.project,
        starkAppKey: this.options.starkAppKey
      }, data)
    }
    this._logQueue.push(log)
    this.send()
  }
}

class ThunderBootloader {
  constructor (state) {
    this.state = state
    this._chunks = []
    this.running = true
    this.type = 'bootloader'
    this.version = '__THUNDER__BUILD_VERSION__'
    this.project = this.state.project
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : ''
    this.logger = new BootLogger({
      version: this.version,
      project: this.state.project,
      starkAppKey: this.starkAppKey
    })
    this._chunkOptions = {
      attrs: assign({}, this.state.outputOptions.attrs),
      config: this.state.outputOptions,
      cacheAge: this.state.cacheAge,
      store: null,
      logger: this.logger,
      updateAdapter: null
    }
    this._thunderCacheKey = `Thunder#${this.starkAppKey || this.project}:sdk`
    this.thunderSDKChunk = new Chunk('thunder-sdk', assign({
      type: 'js'
    }, this.state.outputOptions.thunder), this._chunkOptions)
    this._thunder = null
    this._records = []
    this._timer = null
    this.init()
  }

  init () {
    if (isBrowser) {
      window.__thunder__ = this
    }
    this.tryInitThunder()
    if (this._thunder) return
    this.state.resources.map(r => {
      this._chunks.push(new Chunk(r.name, r, this._chunkOptions))
    })
  }

  tryInitThunder () {
    if (!supportLS) return
    try {
      // sdk cache exist
      if (localStorage[this._thunderCacheKey]) {
        this.thunderSDKChunk._content = localStorage[this._thunderCacheKey]
        return this._createThunder()
      }
    } catch (e) {
      console.error(e)
    }
    // non content, try load thunder SDK
    this._setLoadThunderJob()
  }

  _setLoadThunderJob () {
    clearTimeout(this._timer)
    this._timer = setTimeout(() => {
      this.loadThunder()
    }, 1200)
  }

  _clearThunderCache () {
    localStorage.removeItem(this._thunderCacheKey)
  }

  _createThunder () {
    if (!this.thunderSDKChunk._content) return
    this.thunderSDKChunk.render()
    if (!('Thunder' in window) || this instanceof window.Thunder) return this._clearThunderCache()
    const thunder = new window.Thunder(this.state)
    this._thunder = thunder
    this.logger.markOnce('bootInit', {
      reason: 'bootInit'
    })
    assign(thunder._chunkOptions.attrs, this._chunkOptions.attrs)
    assign(thunder._chunkOptions.config, this._chunkOptions.config)
    this.logger.set(thunder.logger)
    this._records.forEach(({ chunkNames, type }) => {
      // load and cache only
      const chunks = thunder._getChunks(chunkNames, type)
      Promise.all(chunks.map(c => c.load()))
        .then(() => {
          console.log('cached!')
        })
    })
  }

  loadThunder (cb = noop) {
    if (this._thunder) return cb()
    this.thunderSDKChunk._request(err => {
      this.logger.markOnce('bootLoadThunder', {
        reason: 'bootLoadThunder',
        success: !err,
        message: (err && err.message) || ''
      })
      if (err) return cb(err)
      if (!this.thunderSDKChunk._content) return cb(new Error('loadThunder: empty js content'))
      localStorage[this._thunderCacheKey] = this.thunderSDKChunk._content
      this._createThunder()
      cb()
    })
  }

  load (jobs, cb) {
    if (!('Promise' in window)) {
      // set running to false, webpack async chunk will not use thunder
      this.running = false
      // unsupport Promsie, try load thunder sdk
      return this.loadThunder((err) => {
        // try once
        if (err) {
          return this.loadThunder(() => {
            return this._load(jobs, cb)
          })
        }
        return this._load(jobs, cb)
      })
    }
    return this._load(jobs, cb)
  }

  bundleLoader (chunkNames) {
    return this.parallel(chunkNames, 'js')
  }

  scriptLoader (chunkNames) {
    return this.parallel(chunkNames, 'js')
  }

  styleLoader (chunkNames) {
    return this.parallel(chunkNames, 'css')
  }

  parallel (chunkNames, type = 'js') {
    if (this._thunder) return this._thunder.parallel(chunkNames, type)
    this._records.push({
      chunkNames: chunkNames,
      type
    })

    const chunks = this._getChunks(chunkNames, type)
    let queue = Promise.resolve()
    chunks.forEach(c => {
      queue = queue.then(() => c.fallback())
    })
    queue.then(() => {
      this._setLoadThunderJob()
    })
    return queue
  }

  _load (jobs, cb) {
    let queue = Promise.resolve()
    jobs.forEach(job => {
      job.action = job.action || 'load'
      if (job.action !== 'load') return
      queue = queue.then(() => this.parallel(job.chunks, job.type))
    })
    queue.then(() => {
      if (cb) cb()
    })
    return queue
  }

  /*
  * @internal
  * _getChunks
  * @param chunkNames <String> Array or String
  * @param type String
  * @return <Chunk> Array
  */
  _getChunks (_chunkNames, type = 'js') {
    let chunkNames
    const chunks = []

    if (typeof _chunkNames === 'string') {
      chunkNames = [_chunkNames]
    } else {
      chunkNames = _chunkNames
    }

    chunkNames.forEach(name => {
      this._chunks.forEach(c => {
        if (c.type === type && name === c.name) {
          chunks.push(c)
        }
      })
    })

    return chunks
  }
}

export default ThunderBootloader
