import {
  isBrowser,
  request,
  debug,
  assign,
  fakeLogger
} from './util'
import ScriptChunk from './chunk/script'
import StyleChunk from './chunk/style'
import BaseChunk from './chunk/chunk'

export default class Thunder {
  constructor (state) {
    this.state = state
    this.version = '__THUNDER__BUILD_VERSION__'
    this.running = true
    this.type = 'tiny'
    this.starkAppKey = this.state.StarkOptions ? this.state.StarkOptions.projectName : ''
    this._chunks = []
    this.init()
  }

  set ({ nonce, publicPath, attrs, fallbackCDN } = {}) {
    if (nonce) this._chunkOptions.attrs.nonce = nonce
    if (attrs) assign(this._chunkOptions.attrs, attrs)
    if (publicPath) this._chunkOptions.config.publicPath = publicPath
    if (fallbackCDN) this._chunkOptions.config.fallbackCDN = fallbackCDN
  }

  init () {
    if (isBrowser) {
      window.__thunder__ = this
    }
    Thunder._installedPlugins.forEach(plugin => plugin(this))
    if (!this.logger) this.logger = fakeLogger
    this._chunkOptions = {
      attrs: assign({}, this.state.outputOptions.attrs),
      config: this.state.outputOptions,
      cacheAge: this.state.cacheAge,
      store: this.store,
      logger: this.logger,
      updateAdapter: this.updateAdapter.bind(this)
    }
    // match resource
    // js -> create scriptChunk instance
    // css -> create styleChunk instance
    this.state.resources.forEach(resource => {
      Thunder.Chunks.forEach(ChunkConstructor => {
        if (resource.type !== ChunkConstructor.type) return
        this._chunks.push(
          new ChunkConstructor(resource.name, resource, this._chunkOptions)
        )
      })
    })
    // prepare clear unexist chunk cache
    this.store.saveChunksMap(this._chunks.map(c => c.cacheKey))

    this.logger.markOnce('init', {
      channel: 'lx',
      SWSupport: this.serviceWorkerManager && this.serviceWorkerManager.isSupport(),
      useSW: !!this.state.serviceWorker,
      reason: 'init'
    })
  }

  updateAdapter (chunkName, preUpdateData) {
    if (!this._updateAdapter) return Promise.resolve()
    return this._updateAdapter(chunkName, preUpdateData, this, {
      Promise,
      request,
      debug,
      logger: this.logger
    })
  }

  bundleLoader (chunkName) {
    return this.parallel(chunkName)
  }

  styleLoader (chunkName) {
    return this.parallelStyle(chunkName)
  }

  parallelStyle (chunkNames) {
    return this.parallel(chunkNames, 'css')
  }

  load (jobs, cb) {
    let queue = Promise.resolve()
    // load
    jobs.forEach(job => {
      job.action = job.action || 'load'
      if (job.action === 'load') {
        queue = queue.then(() => this.parallel(job.chunks, job.type))
      }
    })
    // prefetch
    jobs.forEach(job => {
      if (job.action === 'prefetch') {
        queue = queue.then(() => this.prefetch(job.chunks, job.type))
      }
    })
    queue.then(() => {
      if (cb) cb()
    })
    return queue
  }

  parallel (chunkNames, type) {
    const chunks = this._getChunks(chunkNames, type)

    return Promise.all(chunks.map(c => c.load()))
      .then(() => {
        let queue = Promise.resolve()
        chunks.forEach(c => {
          queue = queue.then(() => c.render())
        })
        return queue
      })
      .catch(err => console.error(err))
  }

  prefetch (chunks = []) {
    // delay 500ms
    let prefetchChunks = this._getChunks(chunks)
    prefetchChunks = prefetchChunks.concat(this._getChunks(chunks, 'css'))
    return new Promise((resolve, reject) => {
      setTimeout(resolve, 500)
    }).then(() => {
      const unloadChunks = []
      prefetchChunks.map(c => {
        if (!c._content) unloadChunks.push(c)
      })
      return Promise.all(unloadChunks.map(c => c.getContent()))
    })
  }

  /*
  * @internal
  * _getChunks
  * @param chunkNames <String> Array or String
  * @param type String
  * @return <Chunk> Array
  */
  _getChunks (_chunkNames, type = 'js') {
    let chunkNames
    const chunks = []

    if (typeof _chunkNames === 'string') {
      chunkNames = [_chunkNames]
    } else {
      chunkNames = _chunkNames
    }

    chunkNames.forEach(name => {
      this._chunks.forEach(c => {
        if (c.type === type && name === c.name) {
          chunks.push(c)
        }
      })
    })

    return chunks
  }
}

Thunder.StyleChunk = StyleChunk
Thunder.ScriptChunk = ScriptChunk
Thunder.BaseChunk = BaseChunk
Thunder.Chunks = [StyleChunk, ScriptChunk]

Thunder._installedPlugins = []

Thunder.use = function use (...args) {
  const plugin = args.shift()
  const installedPlugins = this._installedPlugins
  if (!plugin || installedPlugins.indexOf(plugin) > -1) {
    return this
  }
  // args.unshift(this)
  // if (typeof plugin.install === 'function') {
  //   plugin.install.apply(plugin, args)
  // } else if (typeof plugin === 'function') {
  //   plugin.apply(null, args)
  // }
  installedPlugins.push(plugin)
  return this
}
