export const isBrowser = typeof window !== 'undefined'

// inspired by https://michalzalecki.com/why-using-localStorage-directly-is-a-bad-idea/
export const supportLS = (function (storage) {
  if (!storage) return false
  try {
    const key = '__LS_SUPPORT_TEST_KEY__'
    storage.setItem(key, key)
    storage.removeItem(key, key)
    return true
  } catch (e) {
    return false
  }
})(window.localStorage)

export const isDEBUG = isBrowser && ('DEBUG_THUNDER' in window) && window.DEBUG_THUNDER
export const supportFetch = isBrowser && ('fetch' in window)
export const isUnitTest = isBrowser && ('UNIT_TEST_THUNDER' in window) && window.UNIT_TEST_THUNDER

const requestDefault = {
  method: 'GET',
  data: null,
  url: ''
}

export function baseFetch (options, callback) {
  window.fetch(options.url, {
    method: options.method,
    body: options.body
  })
    .then(res => {
      if (!res.ok) return callback(res)
      return res.text()
    })
    .then(content => {
      callback(null, content)
    })
    .catch(callback)
}

export function baseXMLHttpRequest (options, callback) {
  const xhr = new window.XMLHttpRequest()
  xhr.withCredentials = false
  xhr.open(options.method, options.url, true)
  xhr.onreadystatechange = function () {
    // load end
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        xhr.onreadystatechange = null
        callback(null, xhr.responseText)
      } else {
        // ajax load failed
        callback(new Error('ThunderError: content load failed'))
      }
    }
  }
  xhr.send(options.body)
}

/*
* request
* @param options : String or Object
* @param cb : Function
*/
export function _request (_options, callback) {
  if (!isBrowser) return callback(new Error('ThunderError: not in browser'))
  const options = {
    method: 'GET',
    data: null,
    url: '',
    body: undefined
  }
  if (typeof _options === 'string') {
    options.url = _options
  } else {
    assign(options, _options)
  }
  // set default method
  if (!options.method) options.method = requestDefault.method

  // force set uppercase
  options.method = options.method.toUpperCase()

  // format data to stringify body
  if (options.data) {
    options.body = JSON.stringify(options.data)
  }

  if (supportFetch) {
    return baseFetch(options, callback)
  }

  return baseXMLHttpRequest(options, callback)
}

export function request (options, cb = noop) {
  return new Promise((resolve, reject) => {
    _request(options, (err, content) => {
      if (err) {
        cb(err)
        reject(err)
      } else {
        cb(null, content)
        resolve(content)
      }
    })
  })
}

export function execModule (content, type, attrs) {
  const head = document.head || document.getElementsByTagName('head')[0]
  let el
  if (type === 'js') {
    el = document.createElement('script')
    el.type = 'text/javascript'
    el.charset = 'utf-8'
    el.text = content
  } else {
    el = document.createElement('style')
    el.type = 'text/css'
    el.charset = 'utf-8'
    el.textContent = content
  }
  if (attrs) {
    keys(attrs).forEach(key => {
      el.setAttribute(key, attrs[key])
    })
  }
  head.appendChild(el)
  if (typeof el.onload === 'function') el.onload()
  return el
}

export function getScriptElement (link) {
  const el = document.createElement('script')
  el.type = 'text/javascript'
  el.charset = 'utf-8'
  el.async = true
  el.timeout = 120000
  el.src = link
  return el
}

export function getLinkElement (link) {
  const el = document.createElement('link')
  el.rel = 'stylesheet'
  el.href = link
  el.timeout = 120000
  el.src = link
  return el
}

export function execModuleAsyncLoad (link, type, attrs, callback) {
  // start chunk loading
  const head = document.head || document.getElementsByTagName('head')[0]
  let el

  if (type === 'js') {
    el = getScriptElement(link)
    if (attrs) {
      keys(attrs).forEach(key => {
        el.setAttribute(key, attrs[key])
      })
    }
  } else if (type === 'css') {
    el = getLinkElement(link)
  }

  if (!el) return callback(new Error('execModuleAsyncLoad: wrong type with ' + type))
  let _onerror = noop
  let _onload = noop

  if (typeof el.onerror === 'function') _onerror = el.onerror
  if (typeof el.onload === 'function') _onload = el.onload

  el.onerror = onScriptError
  el.onload = onScriptComplete

  const timer = setTimeout(() => {
    onScriptError(new Error('execModuleAsyncLoad: timeout ' + link))
  }, 120000)

  function onScriptError (msg) {
    _onerror()
    el.onerror = el.onload = null
    clearTimeout(timer)
    callback(msg)
  }

  function onScriptComplete () {
    _onload()
    // avoid mem leaks in IE.
    el.onerror = el.onload = null
    clearTimeout(timer)
    callback(null, el)
  }
  head.appendChild(el)
  return el
}

export function debug (...args) {
  /* istanbul ignore next */
  if (!isDEBUG) return
  const type = args[0]
  let logger
  /* istanbul ignore if */
  if (console[type]) {
    logger = console[type]
    args.shift()
  } else {
    logger = console.log
  }
  args.unshift('[Thunder]')
  logger.apply(console, args)
}

export function assign (target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object')
  }

  var to = Object(target)
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i]
    if (nextSource === undefined || nextSource === null) {
      continue
    }

    var keysArray = keys(Object(nextSource))
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex]
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey)
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey]
      }
    }
  }
  return to
}

export function keys (obj) {
  if (!isUnitTest && Object.keys) return Object.keys(obj)
  if (obj !== Object(obj)) {
    throw new TypeError('Object.keys called on a non-object')
  }
  const keys = []
  let key
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key)
    }
  }
  return keys
}

export function noop () {}

export function getType (param) {
  return Object.prototype.toString.call(param)
}

export const fakeLogger = {
  markOnce: noop,
  mark: noop,
  markEnd: noop
}
