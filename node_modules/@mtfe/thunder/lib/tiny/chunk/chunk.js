import {
  request,
  noop,
  assign,
  execModuleAsyncLoad
} from '../util'
import crc32 from '../crc32'

export default class Chunk {
  constructor (name, state, options) {
    this.type = ''
    this.name = name
    this.state = state
    this.options = options
    this.store = options.store
    this.logger = options.logger
    this._updateAdapter = options.updateAdapter
    this._content = ''
  }

  get cacheKey () {
    return `<${this.type}>:${this.name}`
  }

  get hash () {
    return this.state.hash || this.filename || this.link
  }

  get link () {
    if (this.state.link) {
      return this.state.link
    } else {
      return this.options.config.publicPath + this.filename
    }
  }

  set fallbackState (value) {
    this.logger.markEnd('fallback:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reason: value
    })
  }

  get fallbackLink () {
    // if link exist (外链资源), use link
    if (this.state.link) {
      return this.state.link
    } else {
      // if fallbackCDN doesn't exist, use publicPath instead
      return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename
    }
  }

  get attrs () {
    return assign({
      'thunder-cache-key': this.cacheKey,
      'crossorigin': this.options.config.crossOriginLoading
    }, this.options.attrs, this.state.attrs)
  }

  load () {
    return this.getContent()
      .then(noop, e => {
        console.error(e)
        // 获取失败时跳过，在 render 中执行缺少 content, 会执行 JSONP fallback
      })
  }

  check () {
    // if state.checksum is not exist, just skip
    // 例如：外链资源
    if (typeof this.state.checksum === 'undefined') return true

    this.logger.mark('check:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reason: 'chunkChecksum',
      size: Math.floor(this._content.length / 1024),
      originChecksum: this.state.checksum,
      reportCost: true
    })
    const checksum = crc32(this._content)
    const isMatch = checksum === this.state.checksum
    this.logger.markEnd('check:' + this.cacheKey, {
      isMatch: isMatch,
      currentChecksum: checksum
    })

    if (isMatch) return isMatch
    // if not match，call clear
    this.store.remove(this.cacheKey)
    return false
  }

  _request () {
    // read from HTTP
    return new Promise((resolve, reject) => {
      request(this.link, (err, content) => {
        if (err) {
          this.logger.markEnd('async:' + this.cacheKey, {
            reason: 'updateFullFailure',
            reportCost: true
          })
          return reject(err)
        } else {
          this._content = content
          this.store.add({
            name: this.cacheKey,
            hash: this.hash,
            cacheAge: this.state.cacheAge || this.options.cacheAge,
            content: this._content,
            filename: this.filename
          })
          this.logger.markEnd('async:' + this.cacheKey, {
            reason: 'updateFullSuccess',
            reportCost: true
          })
          resolve(content)
        }
      })
    })
  }

  update (cached) {
    return this._updateAdapter(this.name, {
      localChunk: cached,
      remoteChunk: this.state
    }).then(payload => {
      // diff failed or skiped
      if (!payload || !payload.content) return this._request()

      // diff success
      this._content = payload.content
      this.store.add({
        name: this.cacheKey,
        hash: this.hash,
        cacheAge: this.state.cacheAge || this.options.cacheAge,
        content: this._content,
        filename: this.filename
      })
      return this._content
    }, e => {
      // diff failed
      console.error(e)
      return this._request()
    })
  }

  getContent () {
    if (this._content) return Promise.resolve(this._content)
    this.logger.markOnce('request:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reason: 'request'
    })
    this.logger.mark('async:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reportCost: true
    })
    // read from CacheStore
    return this.store.get(this.cacheKey)
      .then(cached => {
        // no cache
        // read from HTTP
        if (!cached) return this._request()

        // has local Cache
        const { content, hash } = cached
        // version matched
        if (this.hash === hash) {
          this.logger.markEnd('async:' + this.cacheKey, {
            reason: this.store.type,
            reportCost: true
          })
          this._content = content
          return Promise.resolve(this._content)
        } else {
          // version not matched, try update
          return this.update(cached)
        }
      })
  }

  fallback (execFallback = execModuleAsyncLoad) {
    this.logger.mark('fallback:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reason: 'fallbackStart'
    })
    return new Promise((resolve, reject) => {
      // fallback
      execFallback(this.fallbackLink, this.type, this.attrs, (err) => {
        // success
        if (!err) {
          this.fallbackState = 'fallbackSuccessFrist'
          return resolve()
        }
        // try again fallback link
        execFallback(this.fallbackLink, this.type, this.attrs, (reErr) => {
          if (!reErr) {
            this.fallbackState = 'fallbackSuccessSecond'
            return resolve()
          }
          this.fallbackState = 'fallbackFailure'
          reject(reErr)
        })
      })
    })
  }
}
