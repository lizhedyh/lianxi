import {
  assign,
  execModuleAsyncLoad,
  execModule,
  _request
} from '../util'
import crc32 from '../crc32'

export class Chunk {
  constructor (name, state, options) {
    this.type = state.type || ''
    this.name = name
    this.state = state
    this.options = options
    this.store = options.store
    this.logger = options.logger
    this._updateAdapter = options.updateAdapter
    this._content = state.content || ''
  }

  get cacheKey () {
    return `<${this.type}>:${this.name}`
  }

  get link () {
    if (this.state.link) {
      return this.state.link
    } else {
      return this.options.config.publicPath + this.filename
    }
  }

  get fallbackLink () {
    // if link exist (外链资源), use link
    if (this.state.link) {
      return this.state.link
    } else {
      // if fallbackCDN doesn't exist, use publicPath instead
      return (this.options.config.fallbackCDN || this.options.config.publicPath) + this.filename
    }
  }

  get filename () {
    return this.state.filename
  }

  get attrs () {
    return assign({
      'thunder-cache-key': this.cacheKey,
      'crossorigin': this.options.config.crossOriginLoading
    }, this.options.attrs, this.state.attrs)
  }

  _runScript () {
    if (!this.state.runScript) return
    execModule(this.state.runScript, 'js', this.attrs)
  }

  _request (cb) {
    // read from HTTP
    _request(this.link, (err, content) => {
      if (err) {
        return _request(this.fallbackLink, (_err, content) => {
          if (_err) cb(_err)
          this._content = content
          cb()
        })
      }
      this._content = content
      cb()
    })
  }

  check () {
    // if state.checksum is not exist, just skip
    // 例如：外链资源
    if (typeof this.state.checksum === 'undefined') return true

    const checksum = crc32(this._content)
    const isMatch = checksum === this.state.checksum
    this.logger.markOnce('check:' + this.cacheKey, {
      chunkName: this.cacheKey,
      channel: 'lx',
      reason: 'chunkChecksum',
      size: Math.floor(this._content.length / 1024),
      originChecksum: this.state.checksum,
      isMatch: isMatch,
      currentChecksum: checksum
    })
    return isMatch
  }

  render () {
    if (this._content && (this.options.config.checksum ? this.check() : true)) {
      execModule(this._content, this.type, this.attrs)
      this._runScript()
    } else {
      // 1. 没有 _content, 加载失败
      // 2. checksum 校验和不匹配
      return this.fallback()
    }
  }

  fallback () {
    return new Promise((resolve, reject) => {
      this._fallback(err => {
        if (err) return reject(err)
        resolve()
      })
    })
  }

  _fallback (done) {
    // inline chunk
    if (this.state.content) {
      execModule(this.state.content, this.type, this.attrs)
      return done()
    }
    // fallback
    execModuleAsyncLoad(this.link, this.type, this.attrs, err => {
      // success
      if (!err) {
        this._runScript()
        return done()
      }

      this.logger.markOnce('bootloader:' + this.cacheKey, {
        chunkName: this.cacheKey,
        reason: 'bootFailure'
      })

      // try again fallback link
      execModuleAsyncLoad(this.fallbackLink, this.type, this.attrs, reErr => {
        if (reErr) {
          this.logger.markOnce('bootloader:' + this.cacheKey, {
            chunkName: this.cacheKey,
            reason: 'bootFallbackFailure'
          })
          return done(reErr)
        }
        this._runScript()
        done()
      })
    })
  }
}
