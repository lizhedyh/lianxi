export function getCache (cacheName) {
  return caches.open(cacheName)
}

export function debug (...args) {
  if (!self.serviceWorkerRuntime || !self.serviceWorkerRuntime.options.debug) return
  const type = args[0]
  let logger
  if (console[type]) {
    logger = console[type]
    args.shift()
  } else {
    logger = console.log
  }
  args.unshift('[Thunder-SW]')
  logger.apply(console, args)
}

export function preCache (cacheName, preCacheItems = []) {
  return getCache(cacheName)
    .then(cache => {
      if (cache.addAll) return cache.addAll(preCacheItems)
      // TODO call fetch and cache single
    })
    .then(() => {
      debug('[preCache] cache added', preCacheItems)
    })
    .catch(err => {
      debug(err)
    })
}

export function clearCache (exceptCache, options) {
  const scopeNameKey = `$$$thunder-serviceworker$$$${options.scope}`
  return caches.keys()
    .then(cacheNames => {
      cacheNames.map(cacheName => {
        if (cacheName.indexOf(scopeNameKey) === -1) return

        if (exceptCache !== cacheName) {
          debug('delete ', cacheName)
          caches.delete(cacheName)
        } else {
          debug('current cache is ', exceptCache)
        }
      })
    })
}

export function parseHeader (headers, options) {
  let map = {}
  for (let val of headers.entries()) {
    map[val[0]] = val[1]
  }
  map['X-Thunder-User-Agent'] = options.userAgent
  return map
}

export function simpleFetch (request, options) {
  const sameOrigin = new RegExp('^' + location.origin.replace(/\./g, '\\.').replace(/\//g, '\\/'))
  let job
  if (sameOrigin.test(request.url)) {
    let fetchInit = {
      method: request.method,
      mode: 'cors',
      credentials: 'same-origin',
      headers: parseHeader(request.headers, options)
    }
    // GET or HEAD 请求不能包含 body 信息
    if (request.method !== 'GET' && request.method !== 'HEAD') {
      job = request.blob()
        .then(data => {
          fetchInit.body = data
          return fetch(request.url, fetchInit)
        })
    } else {
      job = fetch(request.url, fetchInit)
    }
  } else {
    job = fetch(request)
  }
  return job
}
