import Logger from './logger'
import CacheManager from './cache-manager'

import { assign, strToReg } from './util'
import { clearCache, debug, preCache } from './helpers'

// eslint-disable-next-line
let scope
if (self.registration) {
  scope = self.registration.scope
} else {
  scope = self.scope || new URL('./', self.location).href
}

const globalOptions = {
  successResponses: /^0|([123]\d\d)|(40[14567])|410$/,
  preCacheItems: [],
  networkTimeoutSeconds: null,
  debug: true,
  strategies: {},
  cacheMaxAgeSeconds: 60 * 60 * 24 * 14,
  maxEntries: 200,
  cache: {
    name: '$$$thunder-serviceworker$$$[thunder-sw-scope]$$$',
    maxEntries: 200,
    queryOptions: null
  },
  userAgent: ''
}

self.addEventListener('sync', function (event) {
  if (event.tag === 'outbox') {
    event.waitUntil(self.serviceWorkerRuntime.syncJob(event))
  }
})

class ServiceWorkerRuntime {
  constructor (options) {
    this.options = assign({}, globalOptions)
    this.cacheManager = null
    this.messageHandler = this._messageHandler.bind(this)
    this.fetchHandler = this._fetchHandler.bind(this)
    this.logger = new Logger()
    this._initJob = null
  }

  init (state = {}) {
    const options = state.serviceWorker
    this.state = state
    if (options.successResponses) options.successResponses = strToReg(options.successResponses)

    this.options = Object.assign(this.options, options)

    this.options.debug = !!options.debug

    this.options.cache.maxEntries = options.maxEntries
    this.cacheManager = new CacheManager(this, this.options, this.state)
    this.cacheManager.$on('msg', this.postMessage, this)
    this.fetchHandler = this._fetchHandler.bind(this)

    this._initJob = this.updateCache()

    return this._initJob
  }

  syncJob (event) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        debug('⚠️ sync_event', event)
        resolve()
        this.postMessage({
          type: 'thudner:sync',
          data: null
        })
      }, 2000)
    })
  }

  postMessage (msg) {
    clients.matchAll({ includeUncontrolled: true })
      .then(clientList => {
        clientList.forEach(client => client.postMessage(msg))
      })
  }

  updateCache () {
    const cacheName = this.options.cache.name
    return clearCache(cacheName, this.options)
      .then(() => preCache(cacheName, this.options.preCacheItems))
  }

  /*
  * _fetchHandler
  * @param event:Event
  * 策略：
  * 判断请求是否可适用 缓存策略
  * 判断是否有 `options.userAgent`
  * 如果已有 userAgent 直接调用 `this.cacheManager.get`
  * 否则尝试在 store 中获取 userAgent，设置 `options.userAgent` 后调用 `this.cacheManager.get`
  *
  *  背景：
  * 在较低版本 webkit/blink (chrome 60-) 下
  * service worker scope 中 navigator.userAgent 与 window.navigator.userAgent 不一致
  */
  _fetchHandler (event) {
    // skip when uninit
    if (!this.cacheManager) return
    const url = event.request.url
    const useCache = this.cacheManager.useCache(event.request)
    let job = Promise.resolve()

    // sync: cancel use cache
    if (!useCache) return

    // without userAgent
    if (!this.options.userAgent) {
      // try read cacheStore async
      this.cacheManager.cacheStore.get('options:userAgent')
        .then(userAgent => {
          this.options.userAgent = userAgent || ''
        })
      // finally skip
    } else {
      // with userAgent
      this.logger.mark(url)
      job = this.cacheManager.get(event.request)

      event.respondWith(job)

      if ('waitUntil' in event) {
        event.waitUntil(job)
      }
    }
  }

  _messageHandler (event) {
    const job = Promise.resolve()

    job.then(() => {
      switch (event.data.command) {
        case 'update:ua':
          this.options.userAgent = event.data.userAgent
          this.cacheManager.cacheStore.set('options:userAgent', event.data.userAgent)
            .then(() => {
              event.ports[0].postMessage({
                error: null,
                data: this.options
              })
            })
          return
        case 'cache:keys':
          return this.cacheManager.keys()
            .then(urls => {
              event.ports[0].postMessage({
                error: null,
                data: urls
              })
            })
        // This command adds a new request/response pair to the cache.
        case 'cache:add':
          // If event.data.url isn't a valid URL, new Request() will throw a TypeError which will be handled
          // by the outer .catch().
          // Hardcode {mode: 'no-cors} since the default for new Requests constructed from strings is to require
          // CORS, and we don't have any way of knowing whether an arbitrary URL that a user entered supports CORS.
          const request = new Request(event.data.url, { mode: 'no-cors' })
          return this.cacheManager.fetchAndCache(request)
            .then(() => {
              event.ports[0].postMessage({
                error: null
              })
            })
        // This command removes a request/response pair from the cache (assuming it exists).
        case 'cache:delete':
          return this.cacheManager.delete(event.data.url)
            .then(success => {
              event.ports[0].postMessage({
                error: success ? null : 'Item was not found in the cache.'
              })
            })
        case 'cache:clear':
          return this.cacheManager.clear()
            .then(() => {
              event.ports[0].postMessage({
                error: null,
                data: 'cache cleared'
              })
            })
        case 'log':
          event.ports[0].postMessage({
            data: this.logger.logQueue
          })
          this.logger.logQueue = []
          return
        case 'store:get':
          return this.cacheManager.cacheStore.get(event.data.key)
            .then(val => {
              return event.ports[0].postMessage({
                val: val
              })
            })
        case 'store:set':
          return this.cacheManager.cacheStore.set(event.data.key, event.data.val)
            .then(() => {
              return event.ports[0].postMessage({
                err: null
              })
            })
        default:
          // This will be handled by the outer .catch().
          throw Error('Unknown command: ' + event.data.command)
      }
    })
      .catch(error => {
        // If the promise rejects, handle it by returning a standardized error message to the controlled page.
        debug('error', 'Message handling failed:', error)
        event.ports[0].postMessage({
          error: error.toString()
        })
      })
    if ('waitUntil' in event) {
      event.waitUntil(job)
    }
  }
}

const thunderStateServiceWorkerStr = '__THUNDER_STATE__SW__'
let thunderStateServiceWorkerOptions = {}

try {
  thunderStateServiceWorkerOptions = JSON.parse(atob(thunderStateServiceWorkerStr))
} catch (e) {
  console.error('ERROR at parsing thunderStateServiceWorkerOptions: ', e)
}

const serviceWorkerRuntime = new ServiceWorkerRuntime()

serviceWorkerRuntime.init(thunderStateServiceWorkerOptions)

export default serviceWorkerRuntime
