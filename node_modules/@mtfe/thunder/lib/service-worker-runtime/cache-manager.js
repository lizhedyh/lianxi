import IndexedDBStorage from './db-wrapper/indexed-storage'
import Emitter from './event'
import { debug, simpleFetch } from './helpers'
import { isLocalhost } from './util'
import {
  CacheFirst,
  CacheAndRefresh,
  StarkDiff
} from './strategies'

const FALSE = false
const isHTTPS = /^https/
const SUCCESS_STATUS_REG = /^0|([123]\d\d)|(40[14567])|410$/

export default class CacheManager extends Emitter {
  constructor (runtime, options = {}, state) {
    super()
    this.runtime = runtime
    this.options = options
    this.cacheName = this.options.cache.name
    this.state = state
    this.cacheStore = new IndexedDBStorage(`$$$thunder-serviceworker$$$${this.options.scope}`)
    this._timer = null
    this.strategies = this.initStrategies()
  }

  initStrategies () {
    const defaulOptions = {
      cacheName: this.cacheName,
      cacheStore: this.cacheStore,
      helpers: {
        logger: this.runtime.logger,
        fetchAndCache: this.fetchAndCache.bind(this),
        isCacheFresh: this.isCacheFresh.bind(this),
        add: this.add.bind(this)
      },
      options: this.options,
      state: this.state
    }
    return [StarkDiff, CacheAndRefresh, CacheFirst].map(StrategyClass => {
      return new StrategyClass(defaulOptions)
    })
  }

  getCache () {
    return caches.open(this.cacheName)
      .then(cache => {
        return cache
      })
  }

  isCacheFresh (req) {
    return this.cacheStore.get(req.url)
      .then(timeMark => {
        if (!timeMark) return false
        const now = Date.now()
        const fresh = (now - timeMark.createdAt) < this.options.cacheMaxAgeSeconds * 1000

        if (fresh) {
          this.cacheStore.set(req.url, {
            createdAt: timeMark.createdAt,
            usedAt: now,
            use: timeMark.use + 1
          })
        }

        return fresh
      })
  }

  shouldCache (request, response) {
    const successResponses = this.options.successResponses || SUCCESS_STATUS_REG
    if (!response) return FALSE
    if (!response.url) return FALSE
    if (request.method !== 'GET') return FALSE
    if (!successResponses.test(response.status)) return FALSE

    return this.useCache(request)
  }

  useCache (request) {
    let useCache = false
    const url = request.url

    // 非开发环境下，所有非 https 请求都放弃缓存
    if (!isLocalhost && !isHTTPS.test(url)) {
      return false
    }

    for (let i = 0, len = this.strategies.length; i < len; i++) {
      if (this.strategies[i].test(request)) {
        useCache = true
        break
      }
    }

    return useCache
  }

  add (req, res) {
    if (!this.shouldCache(req, res)) {
      debug('[CacheManager add]: should not Cache', req.method, req.url)
      return Promise.resolve()
    }

    return this.getCache()
      .then(cache => cache.put(req, res.clone()))
      .then(() => {
        const now = Date.now()
        return this.cacheStore.set(req.url, {
          createdAt: now,
          usedAt: now,
          use: 1
        })
      })
  }

  keys () {
    return this.getCache()
      .then(cache => cache.keys())
      .then(reqs => {
        return reqs.map(req => {
          return req.url
        }).sort()
      })
  }

  /*
  * 尝试在 cache mannager 中请求
  */
  get (req) {
    // try call clearExpiredCaches later
    this._clearJob()

    // match strategy handler
    let handler
    for (let i = 0, len = this.strategies.length; i < len; i++) {
      if (this.strategies[i].test(req)) {
        handler = this.strategies[i]
        break
      }
    }

    if (!handler) {
      debug(`[cacheManager] no strategy to handle this request`, req.url)
      return fetch(req)
    }

    // handleRequest
    return handler.handleRequest(req)
      .then(res => {
        return res
      }, err => {
        // fallback
        debug(`[❌ ${handler.name} error at: ]`, err)
        return fetch(req)
      })
  }

  fetchAndCache (request) {
    return simpleFetch(request, this.options)
      .then(response => {
        if (!this.shouldCache(request, response)) return response.clone()
        this.add(request, response)
        return response.clone()
      })
  }

  _clearJob () {
    // try call clearExpiredCaches later
    if (this._timer) clearTimeout(this._timer)
    this._timer = setTimeout(() => {
      this.clearExpiredCaches()
        .then(() => {
          return this.clearOverSizeCaches()
        })
      this._timer = null
    }, 800)
  }

  clear () {
    this._cache = null
    return caches.delete(this.cacheName)
  }

  clearOverSizeCaches () {
    return this.cacheStore.count()
      .then(count => {
        const maxEntries = this.options.cache.maxEntries || 200
        const removeCount = count - maxEntries
        if (removeCount < 1) return
        return this.clearOldCaches(removeCount)
      })
  }

  clearOldCaches (count = 1) {
    return this.cacheStore.keys()
      .then(caches => {
        const timeMarkedCaches = caches
          .filter(i => i.val && i.val.createdAt)
          .sort((a, b) => {
            return a.val.usedAt - b.val.usedAt
          })

        const queue = []
        for (let i = 0; i < count; i++) {
          const item = timeMarkedCaches.shift()
          if (!item) break
          queue.push(this.delete(item.key))
        }

        return Promise.all(queue)
      })
  }

  clearExpiredCaches () {
    return this.cacheStore.keys()
      .then(caches => {
        const timeMarkedCaches = caches.filter(i => i.val && i.val.createdAt)
        const queue = []
        const now = Date.now()

        timeMarkedCaches.map(item => {
          const timeMark = item.val
          if ((now - timeMark.createdAt) > this.options.cacheMaxAgeSeconds * 1000) {
            queue.push(this.delete(item.key))
          }
        })

        return Promise.all(queue)
      })
  }

  delete (url) {
    return this.getCache()
      .then(cache => {
        return cache.delete(url)
      })
      .then(() => {
        return this.cacheStore.delete(url)
      })
  }
}
