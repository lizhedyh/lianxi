import CacheStrategy from './cache-strategy'

const URL_REG = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/
const URL_PARAMESREG = /[?&]([^=&#]+)=([^&#]*)/g
const PATCH_URL = 'https://jarvas-static.meituan.net/diff/'
const DIFF_PREFIX = '$$$diff_chunk#'
const STARK_PUBLIC_PATH = 's3plus.meituan.net/v1/mss_e2821d7f0cfe4ac1bf9202ecf9590e67/cdn-prod'

const STARK_DIFF_CODE = {
  CLIENT_PATCH_ERROR: 416,
  UNKNOWN_ERROR: 400,
  LOCAL_VERSION_NOT_FOUND: 205
}

function StarkError (message, code) {
  this.message = message
  this.statusCode = code
}

export default class StarkDiff extends CacheStrategy {
  constructor ({ cacheName, cacheStore, helpers, options, state }) {
    super({
      name: 'StarkDiff',
      cacheName,
      cacheStore,
      helpers,
      options
    })
    this.state = state
  }

  handleRequest (req) {
    return this.StarkDiff(req)
  }
  /**
   * diff 主入口
   * @param {Request} req
   */
  StarkDiff (req) {
    // 先从cache中匹配
    return this.getCache()
      .then(cache => {
        return cache.match(req)
      })
      .then((cacheRes) => {
        // 存在cache 则直接返回
        if (cacheRes) return cacheRes
        return this.noCache(req)
      })
  }
  /**
   * 处理缓存不存在的情况
   * @param {Request} req
   */
  noCache (req) {
    const chunkInfo = this.parseUrl(req.url)
    // 如果通过url无法获取chunk信息
    // 直接将请求缓存
    if (!chunkInfo) return this.starkFetch(req)
    const { chunkName } = chunkInfo
    const cacheKey = DIFF_PREFIX + chunkName

    // 尝试根据chunkInfo从indexedDB获取缓存
    return this.cacheStore.get(cacheKey)
      .then((cachChunkInfo) => {
        if (!cachChunkInfo) {
          this.updateChunkInfo(chunkInfo)
          return this.starkFetch(req)
        } else {
          return this.patchChunk(req, chunkInfo, cachChunkInfo)
        }
      })
  }
  /**
   * parse url 暂时通过url参数来获取chunk信息
   * @param {*} url
   */
  parseUrl (_url) {
    const url = decodeURIComponent(_url)
    const parames = url.match(URL_PARAMESREG)

    const chunkObj = {
      chunkName: '',
      hash: '',
      chunkType: '',
      cacheUrl: ''
    }

    if (parames && parames.length) {
      const tmpObj = {}
      parames.forEach(paramStr => {
        const arr = paramStr.split('=')
        tmpObj[arr[0].slice(1)] = arr[1] || ''
      })
      const { chunkName, hash, chunkType } = tmpObj
      chunkObj.chunkName = chunkName
      chunkObj.hash = hash
      chunkObj.chunkType = chunkType

      chunkObj.cacheUrl = url
    }
    if (!chunkObj.chunkName || !chunkObj.hash) {
      return null
    }
    return chunkObj
  }
  /**
   * 自定义请求缓存
   * @param {Request} req
   */
  starkFetch (req) {
    return fetch(req.url)
      .then((res) => {
        this.helpers.add(req, res.clone())
        return res
      })
  }
  /**
   * 更新indexedDB中的chunk信息
   * @param {Object} chunkInfo
   */
  updateChunkInfo (chunkInfo) {
    const { chunkName } = chunkInfo
    return this.cacheStore.set(DIFF_PREFIX + chunkName, chunkInfo)
  }
  /**
   * 获取patch结果 并更新缓存
   * @param {Request} req
   * @param {Object} chunkInfo
   * @param {Object} cachChunkInfo
   */
  patchChunk (req, chunkInfo, cachChunkInfo) {
    // 如果版本一致则直接fetch req
    if (chunkInfo.hash === cachChunkInfo.hash) {
      return this.starkFetch(req)
    }
    const patchLink = this.getPatchLink(chunkInfo, cachChunkInfo)
    const { cacheUrl } = cachChunkInfo
    return Promise.all([
      fetch(patchLink).then((res) => res.json()),
      this.getCache().then((cache) => cache.match(cacheUrl)).then((res) => res ? res.text() : null)
    ]).then((result) => {
      const patchJson = result[0]
      const cacheText = result[1]
      // 获取老版本失败或则patch请求失败
      if (!cacheText || !patchJson) {
        return {
          content: false
        }
      }
      return this.recoverMin(cacheText, patchJson.content)
    }).then((patchRes) => {
      if (!patchRes.content) {
        return this.starkFetch(req)
      }
      const contentString = patchRes.content
      const blob = new Blob([contentString], { type: 'application/javascript' })
      const newRes = new Response(blob)
      // 更新缓存的资源
      this.helpers.add(req, newRes.clone())

      this.updateChunkInfo(chunkInfo)
      return newRes
    })
  }

  /**
   * 拼接patch link
   * @param {Object} chunkInfo
   * @param {Object} cachChunkInfo
   */
  getPatchLink (chunkInfo, cachChunkInfo) {
    const { projectName } = this.state.StarkOptions
    const newPath = this.getPatchPath(chunkInfo.cacheUrl)
    const oldPath = this.getPatchPath(cachChunkInfo.cacheUrl)
    return [PATCH_URL, projectName, '?', 'oldFilePath=', encodeURIComponent(oldPath), '&', 'newFilePath=', encodeURIComponent(newPath)].join('')
  }
  /**
   * 获取patch路径
   * @param {String} url
   */
  getPatchPath (url) {
    const { publicPath } = this.state.outputOptions
    const reg = new RegExp(`.*${publicPath}`)
    return url.replace(reg, '').replace(/\?.*/, '')
  }

  /**
   * 将patch结果更新到原文本
   * @param {String} source 原文本
   * @param {String} patchContent patch结果
   */
  recoverMin (source = '', patchContent = '') {
    const units = patchContent.split('\t')
    let content = source
    let pos = 0

    for (let i = 0; i < units.length; i++) {
      const command = units[i][0]
      if (command === '=') {
        pos += parseInt(units[i].slice(1), 10)
      } else if (command === '-') {
        let length = parseInt(units[i].slice(1), 10)
        content = content.slice(0, pos) + content.slice(pos + length)
      } else if (command === '+') {
        let newPartial = decodeURI(units[i].slice(1))
        content = content.slice(0, pos) + newPartial + content.slice(pos)
        pos += newPartial.length
      } else {
        throw new StarkError('Broken patch found', STARK_DIFF_CODE.CLIENT_PATCH_ERROR)
      }
    }

    return {
      content,
      fullLength: content.length,
      patchLength: patchContent.length
    }
  }

  /**
   * request url中包含publish path并且后缀是js的可以走stark diff
   * @param {Request} request
   */
  test (request) {
    if (!request || !request.url) return false
    const { url } = request
    if (url.indexOf(STARK_PUBLIC_PATH) < 0) return false
    const matches = URL_REG.exec(url)
    const path = matches ? matches[5] : ''
    // TODO: 多类型静态文件
    // 目前只能处理 js
    const arr = path.split('.')
    return arr[arr.length - 1] === 'js'
  }
}
