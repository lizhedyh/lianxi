# 向导

![](http://vfile.meituan.net/scarlett/48ecef7ad639d9a83e4cdcee70ca6eb633889.png)

![''](http://npm.sankuai.com/badge/v/@mtfe/thunder.svg)

> 一个轻量简单易用的 web 资源离线化方案

# 演示

[demo 地址](https://thunderjs.sankuai.com/sw#/c)

# 依赖

- [webpack](https://github.com/webpack/webpack) `2.x` `3.x` `4.x`


### JS loader

一般我们在使用 webpack 打包前端工程时会输出以下文件

```
// 项目入口
app.03960c92d2bd06f8f833.js

// 第三方依赖
vendor.832451b377f15c7bf2f6.js

// webpack runtime 文件
// 不使用相关配置，也可能不独立输出这样的 manifest
// webpack 会将 runtime 打包在 入口文件中
manifest.003ef8accb8625faace6.js

// 异步模块（ async chunk ）
0.69da5a26b16f7d57d6fb.js
1.69da5a26b16f7d57d6fb.js
```

这里的 `app`, `vendor`, `manifest`, `0`, `1` 都是文件模块( chunk ) 的名字。
以下代码实例就是调用 thunder 加载 `app` 模块。


```javascript
thunder.bundleLoader('app');
```

#### JS 加载和执行

thunder 实现了对 JS 的离线缓存，所以并不是所以 JS 加载来自网络请求。
在常见的 webpack 项目工程中一般将 JS 模块拆分为 

- webpack runtime `manifest`
- 外部依赖模块或公用模块 `vendor`
- 业务代码 `app`

这几个模块的对执行顺序是有一定要求的，所以使用 thunder 申明加载模块也需要遵循这个执行顺序：

```javascript

thunder.bundleLoader('manifest')
  .then(() => thunder.bundleLoader('vendor'))
  .then(() => thunder.bundleLoader('app'))

```

上面调用 `bundleLoader` 能够成功执行代码，但有一个问题是这里加载和执行 JS 是顺序的，可能在没有可用缓存的情况下使用网络请求加载 JS 比非 thunder 模式更慢。

所以 `thunder` 提供了一个并行加载方法 `parallel`

```javascript

thunder.parallel(['manifest', 'vendor', 'app'])

```

#### webpack plugin -> chunksMap

`thunder` 之所以能够通过传入 `chunk name` 就可以实现加载相应 JS 模块，是因为 `thunder` 通过 hook webpack 的编译，获取输出的 chunk 信息

在编译完成后输出 `thunder-state.json` 文件就是 thunder plugin 生成的相关配置和 chunk 信息文件

```json
{
  "chunksMap": {},
  "compilation": {},
  "project": "simple",
  "outputOptions": {},
  "resources": {}
}

```
- chunksMap 是所有 JS Chunk 的模块名和版本信息
- compilation 来自 webpack 编译版本信息
- project 是 thunder 的项目名配置
- outputOptions 来自 webpack 的输出配置，包含 entry chunk / async chunk 文件模板等
- resources 是 webpack 输出的 js / css 文件名信息，用于HTML 模板静态资源注入


#### stark

thunder 内置了 stark 插件，配置 stark 相关配置项之后就可以使用 stark diff 更新功能

#### sw register

在配置了 thunder service worker 相关配置后，thunder JS loader 会自动进行 service worker 注册

- sw 离线化

参考 sw 配置

## 安装和配置

thunder 目前支持以下两种模式接入，区别主要在于模板注入的方式。

### 安装

```bash

npm install @mtfe/thunder

```

### 在 webpack 配置中加入 ThunderPlugin

推荐在 `非开发环境` webpack 配置中引入 `Thunder`, 因为 `Thunder` 的缓存特性在开发中并不需要。

```javascript
// webpack.conf.production.js

const ThunderPlugin = require('@mtfe/thunder/plugin')

const webpackConfig = {

  plugins: [
    ...
    new ThunderPlugin()
    ...
  ]
  ...
}
```

### 纯静态项目

纯静态项目只需要通过 `injectHTML` 配置模板资源注入就可以完成 thunder 的接入

```javascript
// webpack.conf.production.js

const ThunderPlugin = require('@mtfe/thunder/plugin')

const webpackConfig = {

  plugins: [
    ...
    new ThunderPlugin({
      project: 'com.meituan.era',
      injectHTML: {
        template: path.resolve(__dirname, 'path/to/your/template/index.html'),
        chunks: ['manifest', 'vendor', 'app']
      }
    })
    ...
  ]
  ...
}
```

你需要配置的是 `injectHTML` 中 `chunks` 这里是为了调用 thunder loader 加载第三方资源模块 (vendor)以及入口模块 (app), 请根据项目的相关配置填写这里的配置。


### node server 项目

webpack 编译打包后会输出 `thunder-state.json`, 只需要在 `path` 处配置 `thunder-state.json` 的绝对路径或者自行引入 `thunderState`

```
const thunderState = require('path/to/thunder-state.json')

const thunderInjector = require('@mtfe/thunder/server/injector')({
    path: 'path/to/thunder-state.json',
    // 选择传入 path 或者 直接传入 thunderState
    thunderState: thunderState,


    chunks: ['manifest', 'vendor', 'entry']
})

```

上面的代码初始化完成了 `thunderInjector` , 下面就可以直接使用 `getStylesContent` 和 `getScriptContent` 方法来完成注入


```javascript
class HomeController {
    view (ctx) {
        ctx.render('template.html', {
          styleContent: thunderInjector.getStylesContent(),
          scriptContent: thunderInjector.getScriptContent()
        })
    }
}

```

```html
<!DOCTYPE html>
<html lang="zh_CN">
    <head>
        <meta charset="utf-8">
        <title>test</title>

        {{{ styleContent }}}
    </head>
    <body>
        <div id="app"></div>
        {{{ scriptContent }}}
    </body>
</html>

```


### 详细配置

#### webpack plugin 配置项

这里是目前 `Thunder` 支持的所有配置选项，包括 异步 chunk 名称使用 HASH, 弱网策略, stark 字符级更新配置，serviceWorker 等, 相关详细配置请继续向下阅读或者搜索当前页面。


```javascript
// webpack.config.js

module.exports = {
  ...

  plugins: [
    new ThunderPlugin({
      // 管理输出文件名
      output: {
        // 设置 false 即表示不输出该文件
        // state: false,
        state: 'thunder-state.json',
        
        // thunder sdk script 支持 [hash] 关键词
        thunder: 'thunder.[hash].js',
        
        serviceWorker: 'service-worker.js'
      },
      // 异步 chunk 名称
      pathNameHash: false,
      
      // 弱网策略
      networkTactic: true,
      
      // 项目名称
      project: 'simple',

      // Stark 相关配置
      StarkOptions: {
        "projectName": "3d07127a",
        "dist": "dist"
      },

      // serviceWorker 配置
      serviceWorker: {
        path: '/static/service-worker.js',
        scope: '/pay'
      }
    })
  ]

  ...
}
```