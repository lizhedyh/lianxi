# ServiceWorker

PWA 给 web 带来了很多想象空间（离线化，消息push...），让 web 应用也能够享受接近 native 的体验。PWA 中有一个非常重要的技术就是 service worker（衍生自HTML5中的web worker规范）,它让资源真正的离线缓存成为了可能。想要使用 service worker 其实也并不是那么容易，需要非常熟悉 service worker 的生命周期，以及做好相关的资源缓存管理工作，但是现在不用去担心这些额外的工作，`thunder` 已经帮你做好了，你仅仅需要做一下相关配置就能马上享受到 service worker 的缓存体验。

通过以下三步就能开始使用 `Service-worker`：

## 开始使用 Service-worker

### 第一步 在 plugin 中增加 `serviceWorker` 配置

配置说明：

path: 用于 thunder SDK 注册 service-worker.js URL 地址, 也就是说让 SDK 知道应该以什么 URL 来注册 service worker
scope: 用于配置 service worker 工作的路由目录, 为 '/' 即表示在当前域名下所有路由都启用这个 service worker
strategies: 请参考下面的 `缓存策略` 章节

```javascript
new Thunder({
    
    ...

    // 启用serviceWorker 配置
    serviceWorker: {
        // 用于 thunder SDK 注册 service-worker.js URL 地址
        path: '/sw/service-worker.js',
        // 用于配置 service-worker 工作的路由目录
        scope: '/pay',
        // 缓存策略配置
        strategies: {
            CacheFirst: {
                // 排除不需要 sw 缓存的资源
                excludes: ['\\/api\\/'],
                // 需要 sw 缓存的资源
                includes: ['p1\\.meituan\\.net', 'static\\.meituan\\.net'],
            }
        }
    }
})
```

可以理解为 Thunder SDK 根据这里的配置在内部调用了以下方法：

```javascript
navigator.serviceWorker.register('/sw/service-worker.js', {
  scope: '/pay'
});
```

如果你还不太了解 service worker, 可以参考 

[服务工作线程：简介](https://developers.google.com/web/fundamentals/primers/service-workers/?hl=zh-cn)

[使用 Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)


### 第二步 Koa / Express 中输出 `service-worker.js`

`injector` 的 `getServiceWorkerContent()` 方法来获取构造好的 service worker 

这里设置路由 `router.get('/sw/service-worker.js')` 就是和我们上面配置的 `path` 相对应的，也就是说，当我们配置完成时，浏览器接收到 service-worker 的注册请求，就会发送请求 `https://www.xxx.com/sw/service-worker.js` 来请求 service-worker 的文件。

比如应用有一下几个路由路径，我们想将 `/news/` 下这几个页面都使用 service worker 缓存:

```
https://someapp.meituan.com/news/
https://someapp.meituan.com/news/detail/:id
https://someapp.meituan.com/news/photos
```

只需要在返回 service worker 的脚本 header 中 `Service-Worker-Allowed` 设置 `/news`, 就可以设定这个 service worker 将会工作在所有 `/news` 下路径中了。

```javascript

const getThunderInjector = require('../packages/thunder/server/injector')
const thunderState = require('path/to/thunder-state.json')

const injector = getThunderInjector({
  thunderState,
  chunks: []
})
const serviceWorkerContent = injector.getServiceWorkerContent()

// Koa
router.get('/sw/service-worker.js', ctx => {
  // 如果 service-worker.js 的路径和工作的页面不是一个目录内，需要使用 `Service-Worker-Allowed` 来指定。
  ctx.set({
    'Content-Type': 'application/javascript; charset=UTF-8',
    'Service-Worker-Allowed': '/news',
    // 推荐设置以下代码，让 service-worker.js 不被 HTTP 缓存
    'Cache-Control': 'no-store, no-cache, must-revalidate'
  })
  
  ctx.body = serviceWorkerContent
})

// Express
app.get('/sw/service-worker.js', (res, res) => {
  res.set({
    'Content-Type': 'application/javascript; charset=UTF-8',
    'Service-Worker-Allowed': '/news',
    // 推荐设置以下代码，让 service-worker.js 不被 HTTP 缓存
    'Cache-Control': 'no-store, no-cache, must-revalidate'
  })

  res.body = serviceWorkerContent
})

```

完成以上两步，就大功告成了，可以测试你的项目是否正确启用了 service worker 功能。


在 Chrome 开发者工具 `Application` 中 `service workers` 下会看到有一个正常工作的 service-worker

![](http://vfile.meituan.net/scarlett/e927d8135514410d0100746334bb3180111727.png)

在 Chrome 开发者工具 `Network` 中能够看到被缓存策略标记缓存的 URL 资源会显示 `(from ServiceWorker)`

![](http://vfile.meituan.net/scarlett/fa25cd7dc898f3f5da247ffecee5220a145351.)


如果没有成功启用了 service worker ，请排查以下问题：

- 当前域名是否是 `https` 
- 如果是本地环境，是否是 `127.0.0.1` 或 `localhost`
- 是否正确配置了 path / scope
- 修改过配置是否重新运行 webpack 打包，打包完成后是否重启了 node 服务

## 配置详情

### 预加载

通过配置 `preCacheItems` 就可以对资源进行预加载, 支持相对路径和绝对路径的 URL。

例如:

```javascript
{
  serviceWorker: {
    path: '/static/service-worker.js',
    scope: '/pay',

    // 需要预加载的资源
    preCacheItems: [
      '/home',
      'https://cdn.com/home.css'
    ]
  }
}
```

### 缓存周期和数量控制

通过配置 `cacheMaxAgeSeconds` 就可以对缓存的生存周期进行控制， `maxEntries` 则是控制缓存的数量，超过缓存数量限制会自动清理相对较老的缓存。

例如:

```javascript
{
  serviceWorker: {
    path: '/static/service-worker.js',
    scope: '/pay',

    // 缓存的时效, 默认 1209600 (14 天)
    cacheMaxAgeSeconds: 1209600,

    // 缓存数限制，默认 200
    maxEntries: 100,
  }
}
```

## 缓存策略

在 `Thunder Service-worker` 中，预设了一系列的策略，这些策略通过 `strategies` 下的相关配置就可以对静态资源启用相应的策略。

> 注意目前现有策略规则的配置项有：CacheFirst、CacheAndRefresh，都为首字母大写的驼峰格式。

```javascript
{
  serviceWorker: {
    path: '/static/service-worker.js',
    scope: '/pay',
    
    // 策略配置
    strategies: {
      CacheAndRefresh: ['\\.json'],
      CacheFirst: {
        excludes: ['/api/'],
        includes: ['.*'],
      }
    }
  }
}
```

### CacheFirst

`CacheFirst` 是一个基础策略，具体策略为：如果有本地缓存，直接使用本地缓存，直到缓存过期失效才会再次发起网络请求。

这个策略适用于绝大部分静态资源，如：图片、JS、CSS、字体文件等

> `excludes` `includes` 用于构造 RegExp 的字符数组, 用于匹配 GET 请求中的 URL。由于 [Mixed Content](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content) , 导致资源不能被正常加载。默认 service worker 不会缓存 http 内容。

如下配置，就是表示启用 `CacheFirst` 策略，缓存所有来自 `static\\.meituan\\.com` 的资源，其中排除包含 `api` 的资源。

```javascript
strategies: {
  CacheFirst: {
    excludes: ['/api/'],
    includes: ['static\\.meituan\\.com'],
  }
}
```

### CacheAndRefresh

`CacheAndRefresh` 是一个基础策略，具体策略为：是优先返回缓存中的资源，同时会向服务器请求该资源。

这个策略适用于页面

如下配置，就是表示启用 `CacheFirst` 策略，缓存所有来自 `https://thunderjs.sankuai.com/sw` 或者 `http://localhost:3000/sw` 下的资源，也就是 `/sw` 下的页面等资源。


```javascript
strategies: {
  CacheAndRefresh: {
    includes: [
    'thunderjs\\.sankuai\\.com\\/sw',
    'localhost:3000\\/sw'
    ]
  }
}
```

以上配置等价于：

```javascript
strategies: {
  CacheAndRefresh: [
    'thunderjs\\.sankuai\\.com\\/sw',
    'localhost:3000\\/sw'
  ]
}
```


## 详细配置

```javascript
{
  serviceWorker: {
    path: '/static/service-worker.js',
    scope: '/pay',

    // 需要预加载的资源
    preCacheItems: [
      '/home',
      'https://cdn.com/home.css'
    ],
    
    // 缓存数限制，默认 200
    maxEntries: 100,

    // 缓存的时效, 默认 1209600 (14 天)
    cacheMaxAgeSeconds: 10,

    strategies: {
      // 需要使用 CacheAndRefresh 策略的资源
      CacheAndRefresh: ['\\.json'],

      // 静态缓存 CacheFirst 策略的资源
      CacheFirst: {
        // 排除不需要 sw 缓存的资源
        excludes: ['/api/', 'frep\\.meituan\\.net', '^http://'],

        // 需要 sw 缓存的资源
        includes: ['.*'],
      }
    }
  }
}
```

## ServiceWorker 相关问题

### 业务依赖解析 userAgent 


因为在目前测试中发现微信，美团等 webview 中 [ServiceWorkerGlobalScope](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope) 中 `navigator.userAgent`
可能不会和 `window.navigator.userAgent` 同步，通过 service-worker 处理的请求 header 中 userAgent 可能不是容器定义的，所以在 service-worker 中加入了自定义字段 `X-Thunder-User-Agent`, 建议 server 端优先使用 `X-Thunder-User-Agent`。


```javascript

const userAgent = req.headers['x-thunder-user-agent'] || req.headers['user-agent']

```

### manifest.json 文件

网络应用清单是一个 JSON 文件，您（即开发者）可以利用它控制在用户想要看到应用的区域（例如移动设备主屏幕）中如何向用户显示网络应用或网站，指示用户可以启动哪些功能，以及定义其在启动时的外观。

详情请参考 [网络应用清单](https://developers.google.com/web/fundamentals/web-app-manifest/?hl=zh-cn)、

在页面中声明 `manifest` 

```html
<link rel="manifest" href="/static/manifest.json">
```

`manifest.json` :

```json
{
  "name": "my-app",
  "icons": [
    {
      "src": "/android-chrome-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/android-chrome-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "theme_color": "#181743",
  "background_color": "#181743",
  "start_url": "/",
  "display": "standalone"
}
```

### 在多个不同项目使用相同域名的场景中如何使用 service worker

在实际场景中，有可能多个业务项目共用同一域名，通过 nginx 配置等方式分管不同的路由

比如：

下面的例子中 `news`、 `shop` 共同运行在 `someapp.meituan.com` 域名下：

```
https://someapp.meituan.com/news/
https://someapp.meituan.com/news/detail/:id
https://someapp.meituan.com/news/photos


https://someapp.meituan.com/shop/
https://someapp.meituan.com/shop/detail
https://someapp.meituan.com/shop/detail/:id
```

对于共用域名的项目来说，只需要配置好不同项目的 `scope` , 让 service worker 独立的工作在不同项目下。

可以这样组织 `service-worker.js`

```
项目 A: https://someapp.meituan.com/sw/news-service-worker.js
项目 B: https://someapp.meituan.com/sw/shop-service-worker.js

```

项目 A:

```javascript
router.get('/sw/news-service-worker.js', ctx => {
  ctx.set({
    'Content-Type': 'application/javascript; charset=UTF-8',
    'Service-Worker-Allowed': '/news',
    'Cache-Control': 'no-store, no-cache, must-revalidate'
  })

  ctx.body = serviceWorkerContent
})
```
项目 B:

```javascript
router.get('/sw/shop-service-worker.js', ctx => {
  ctx.set({
    'Content-Type': 'application/javascript; charset=UTF-8',
    'Service-Worker-Allowed': '/shop',
    'Cache-Control': 'no-store, no-cache, must-revalidate'
  })

  ctx.body = serviceWorkerContent
})
```


### thunder 的 sw 有缓存回收和过期机制吗？是怎样的机制？

在 thunder 的有缓存回收机制。请求被缓存写入就会记录 `createdAt`, 如果当前时间和 `createdAt` 差超过 `cacheMaxAgeSeconds` 时间（秒）就会回收过期的缓存。
还有一项关键的配置 `maxEntries`（默认 200）, 在 cacheStorage 中，大量的资源被缓存会导致取出的耗时增加，所以会有缓存数量的限制，超过缓存数量的限制会进行 LRU 策略的回收。


### 我能存储多少数据？

| 浏览器         | 限制          |
| ------------- |:-------------:| 
| Chrome        | 可用空间 <6%   |
| Firebox       | 可用空间 <10%  | 
| Safari        |  <50MB        |
| IE10          |  <250MB       |

### 如何了解我的应用目前使用了多少存储空间？

在 Chrome 中，您可以使用 [Quota Management API](https://www.w3.org/TR/quota-api/) 查询目前使用的存储空间大小，以及应用可使用多少空间。更新的 [Storage Quota Estimate API](https://www.chromestatus.com/features/5630353511284736) [StorageManager](https://developer.mozilla.org/en-US/docs/Web/API/StorageManager) 尝试通过支持 Promise，让用户更容易了解源目前使用了多少配额。


### 缓存逐出是如何工作的？


| 浏览器         | 限制          |
| ------------- |:-------------:| 
| Chrome        | 在 Chrome 耗尽空间后采用 LRU 策略   |
| Firebox       | 在整个磁盘已装满时采用 LRU 策略  | 
| Safari        | 无逐出       |
| IE10          | 无逐出    |

### 如何注销 ServiceWorker

当 thunder 配置中没有 `serviceWorker` 配置项时，thunder loader sdk 会自动调用注销 ServiceWorker。

以下代码可以帮助手动注销 ServiceWorker:

```javascript
if (SUPPORT_SERVICE_WORKER) {
  // chrome 40, single
  if (navigator.serviceWorker.getRegistration) {
    navigator.serviceWorker.getRegistration()
      .then(registration => {
        if (!registration) return
        registration.unregister()
        debug('sw unregisted')
      })
      .catch(err => {
        debug('error', 'unregister', err)
      })
  }
  // chrome 40 after
  if (navigator.serviceWorker.getRegistrations) {
    navigator.serviceWorker.getRegistrations()
      .then(registrations => {
        registrations.forEach(registration => {
          registration.unregister()
        })
        debug('sw unregisted')
      })
      .catch(err => {
        debug('error', 'unregister', err)
      })
  }
}
```

