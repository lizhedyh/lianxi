# JS loader 机制

## Thunder 的 JS 资源加载方式

`thunder` 加载 JS 有两种方式：

- 同步：有 LS 缓存，同步从 localStorage 读取，最后执行
- 异步：没有 LS 缓存，或者是较老版本，异步请求更新补丁或者全量文件，最后执行

## Thunder 的加载模式和标签引入方式的区别

在常规浏览器的加载时间统计中，比如 cat 中的 `DOM-Ready` `DOMContentLoaded`，是表示 DOM 树构建完毕，但在浏览器解析 HTML 的过程中，内联 `<script>`的解析、执行以及外联的 `<script>` 的加载、解析、执行都会导致 HTML 解析暂停。

```javascript
thunder.parallel(['manifest', 'vendor', 'app'])
```

比如上面是 thunder 常见的加载调用方式，根据本地缓存情况就会有两种不同的方式影响。

- 同步：同步读取 LS 加载，同步执行, `DOMContentLoaded` 近似普通外联 JS 方式
- 异步：异步 (Ajax/Fetch) 请求 CDN 加载，同步执行, `DOMContentLoaded` 早于 业务 JS 执行

## 缓存外链资源

thunder 在 2.0 之后支持对外链资源的缓存，因为 thunder 是通过 fetch / XMLHttpRequest 方式获取的资源内容的，所以和普通资源一样需要确定外链资源资源的 CDN 支持跨域请求。

在确认 CDN 支持的情况之后，就可以通过在 thunder plugin 中 `resources` 增加相应资源：

```javascript
new ThunderPlugin({
  
  ...

  resources: {
    js: {
      'axios': '/axios.js',
      lx: {
        link: '//analytics.meituan.net/analytics.js',
        cacheAge: 3600 * 24 * 7 // 单位为秒，7 天
      },
    },
    css: {
      'google-font': '//fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic',
      'google-icon': '//fonts.googleapis.com/icon?family=Material+Icons'
    }
  }
})
```

下面的代码表示：

首先加载 'google-font' 'google-icon' 这两个 CSS 资源，加载完成之后开始加载 axios 以及 manifest、vendor、app 

```javascript

thunder.styleLoader(['google-font', 'google-icon'])
  .then(function () {
    thunder.parallel(['axios', 'manifest', 'vendor', 'app'])
  })

```

## 性能打点

例如利用 [Cat 自定义测速点](http://cat.sankuai.com/cat/s/frontend?op=speedVue#/list) 来统计性能：

```javascript
export default {
  ...

  created () {
      const markStart = window.performance.timing.navigationStart
      window.Owl.addPoint({
        position: 0,
        duration: Date.now() - markStart
      })
  },
  mounted () {
      const markStart = window.performance.timing.navigationStart
      window.Owl.addPoint({
        position: 1,
        duration: Date.now() - markStart
      })
  }
};

```


## Thunder SDK 架构

thunder sdk 中主要有 4 个重要模块，分别是：

- `loader`： 负责相关资源模块的加载
- `logger`： 相关性能数据统计上报的模块
- `store`：localStorage 的封装，负责资源的存储和回收管理
- `service worker manager`：service worker 的注册和管理模块

![thunder 模块架构图机制](http://vfile.meituan.net/scarlett/f442401ba0ce16919ed5a3998af98ecb44956.)


## 模块加载流程图

![thunder 模块加载机制](https://mss.sankuai.com/v1/mss_f20b28c4592e489eafafa4a68cf5feea/mind-image/nt/1525747546588_HkXDkcApz.png)


### 改变 JS 资源加载执行逻辑

通常来说你是不需要关心 js 资源的加载与执行逻辑的，`thunder` 已经根据你的 `chunks`配置做好了相关处理，但是如果你想要自己手动处理，`thunder` 对外暴露了相关方法来满足你的需求。


构建配置作如下变动：

```javascript
...
new Thunder({
    //项目名称
    project: "example",
    //模板注入配置
    injectHTML: {
        // 开发模板的绝对路径
        template: path.resolve(__dirname, 'path/to/your/template/index.html'),
        
        // 使用自定义的启动脚本
        content:`
        ;(function (global) {
            var thunder = global.__thunder__
            thunder.parallel(['manifest', 'vendor', 'app'])
                .then(function () {
                    console.log('all chunks loaded')
                })
        })(window)
        `
    }
}),
...
```

在这里，我们将 `chunks` 配置去掉，添加了 `content` 配置，thunder 插件会将 `content` 配置作为最高优先级处理，即使你配置了 `chunks` 也不会处理。

同理 node server 中的代码改动如下;

```javascript
//server.js
const thunderState = require('path/to/thunder-state.json')

const thunderInjector = require('@mtfe/thunder/server/injector')({
    //也可以通过path的方式引用thunder-state.json
    //path: 'path/to/thunder-state.json'
    thunderState: thunderState,
    content:`
    ;(function (global) {
        var thunder = global.__thunder__
        thunder.parallel(['manifest', 'vendor', 'app'])
            .then(function () {
                console.log('all chunks loaded')
            })
    })(window)
`
})
```

当然，你也可以不把启动的脚本写入配置中，而是直接放置在模板上，就像下面的例子一样：


```html
<!DOCTYPE html>
<html lang="zh_CN">
    <head>
        <meta charset="utf-8">
        <title>test</title>

        {{{ styleContent }}}
    </head>
    <body>
        <div id="app"></div>
        {{{ scriptContent }}}
        <script>
            //方式一：
            //并行加载，顺序执行
            ;(function (global) {
                var thunder = global.__thunder__
                thunder.parallel(['manifest', 'vendor', 'app'])
            })(window)

            //方式二：
            //顺序加载，顺序执行
            ;(function (global) {
                var thunder = global.__thunder__
                thunder.bundleLoader('manifest')
                .then(function () {
                    return thunder.bundleLoader('vendor')
                })
                .then(function () {
                    return thunder.bundleLoader('app')
                })
            })(window)
        </script>
    </body>
</html>
```

thunder 提供的 `parallel()` 和 `bundleLoader()` 两个方法来加载。

- `parallel()` 方法：接受一个严格按照webpack运行时的依赖关系数组参数，它将会按照你传入的参数来并行加载资源然后顺序执行，此方法会返回promise。当你配置chunks时，thunder默认就是调用的这个方法，同时也建议读者使用此方法。
- `bundleLoader()` 方法：接受一个chunk名称，它会立即加载它并执行，此方法也会返回promise。

### 异步加载模块处理

当应用打包体积越来越大时，我们通常会考虑利用 webpack 提供的打包异步模块的能力，把一些不需要首屏展现的资源改为异步按需加载。

不用担心 thunder 无缝支持 webpack 异步模块异步加载：

```
// 同步引入
import { add } from '../lib.js'

add(1, 2)


// 在 webpack 中使用异步模块加载
import('../lib.js')
    .then({ add } => {
            add(1, 2)
        })
```

使用异步模块之后，会看到编译打包输出的 JS 中会有很多 `0.xxx.js`, `1.xxx.js` 这样的数字命名的文件。其中数字是 `Webpack` 分配给匿名 chunk 的索引。数字的索引会因为开发过程中的模块引用变化造成比较大的变动，不利于缓存命中，所以推荐将所有异步模块都命名一个唯一的 chunkName。如何配置解决这个问题
请参考 [异步 chunk](./depth/suggestion/#chunk)

