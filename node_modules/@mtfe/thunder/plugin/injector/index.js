const path = require('path')
const assert = require('assert')
const fs = require('fs')
const glob = require('glob')
const Injector = require('./injector')
const {
  SimpleWebpackSource
} = require('../util')

const STYLE_INJECT_REG = /<!--thunder-style-inject-->/i
const SCRIPT_INJECT_REG = /<!--thunder-script-inject-->/i
const HEAD_REG = /(<\/head\s*>)/i
const BODY_REG = /(<\/body\s*>)/i

function inject (options, compilation, thunderState) {
  assert(options.template, 'injectHTML.template could not be empty')
  const injector = new Injector(thunderState, options)
  return new Promise((resolve, reject) => {
    let contents = []
    if (typeof options.template === 'function') {
      Promise.resolve(options.template(options, compilation, thunderState))
        .then(content => {
          if (typeof content === 'string') {
            contents.push({
              filename: options.filename,
              content: content
            })
          } else if (content instanceof Array) {
            contents = content.concat(content)
          } else {
            reject(new Error('injectHTML.template must return string or Array'))
          }
          resolve(contents)
        })
    } else {
      // 读取
      glob(options.template, (err, files) => {
        if (err) return reject(err)
        files.forEach(file => {
          contents.push({
            filename: options.filename || path.basename(file),
            content: fs.readFileSync(file, 'utf-8')
          })
        })
        resolve(contents)
      })
    }
  }).then(contents => {
    contents.map(({ filename, content }) => {
      injectToHtml(filename, content, injector, compilation)
    })
  })
}

function injectToHtml (filename, content, injector, compilation) {
  let outputContent = content

  // 如果配置了 styles, 不再注入 css 标签
  if (!injector.options.styles.length) {
    if (STYLE_INJECT_REG.test(outputContent)) {
      outputContent = outputContent
        .replace(STYLE_INJECT_REG, m => injector.getStylesContent())
    } else {
      outputContent = outputContent.replace(HEAD_REG, match => injector.getStylesContent() + match)
    }
  }

  if (SCRIPT_INJECT_REG.test(outputContent)) {
    outputContent = outputContent.replace(SCRIPT_INJECT_REG, m => injector.getScriptsContent())
  } else {
    outputContent = outputContent.replace(BODY_REG, match => injector.getScriptsContent() + match)
  }

  // 如果是绝对路径，直接写入文件，不使用 webpack output
  if (path.isAbsolute(filename)) {
    fs.writeFileSync(filename, outputContent, 'utf-8')
  } else {
    compilation.assets[filename] = SimpleWebpackSource(outputContent)
  }
}

module.exports = (options, compilation, thunderState) => {
  if (Array.isArray(options)) {
    return Promise.all(options.map(opt => inject(opt, compilation, thunderState)))
  }
  return inject(options, compilation, thunderState)
}
