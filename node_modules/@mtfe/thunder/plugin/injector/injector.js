const assert = require('assert')
const { resolve } = require('path')
const Vnode = require('./vnode')
const ChunkMatcher = require('./matcher')
const {
  getThunderScript,
  getServiceWorkerScript
} = require('../util')
const {
  genLoaderInitScript
} = require('./util')

class Injector {
  constructor (state, options) {
    this.state = JSON.parse(JSON.stringify(state))
    // 废弃使用 chunksMap
    delete this.state.chunksMap

    this.options = Object.assign({
      disable: false,
      inline: true,
      prefetch: false,
      chunks: [],
      styles: [],
      mode: 'tiny'
    }, options)

    // if content is't exist, must have chunks
    if (!this.options.content) assert(Array.isArray(this.options.chunks), 'options.chunks must be an array')
    this.matcher = new ChunkMatcher({
      resources: state.resources,
      publicPath: state.outputOptions.publicPath
    })
  }

  getStyleNodes () {
    const styles = this.matcher.getStyles(this.options.chunks)

    return styles.map(style => new Vnode({
      tag: 'link',
      selfClose: true,
      attrs: {
        rel: 'stylesheet',
        href: style.link
      }
    }))
  }

  getScriptNodes (options = {}) {
    const state = JSON.parse(JSON.stringify(this.state))
    const { nonce, disable, publicPath, attrs, fallbackCDN } = options
    state.outputOptions.attrs = Object.assign(state.outputOptions.attrs || {}, attrs)
    if (nonce) state.outputOptions.attrs.nonce = nonce
    if (publicPath) state.outputOptions.publicPath = publicPath
    if (fallbackCDN) state.outputOptions.fallbackCDN = fallbackCDN

    if (!disable) {
      return [
        new Vnode({
          tag: 'script',
          attrs: {
            type: 'application/javascript',
            nonce: nonce,
            src: this.options.inline ? '' : resolve(state.outputOptions.publicPath, state.outputOptions.thunder.filename)
          },
          children: [this.options.inline ? getThunderScript(state, this.options.mode) : '']
        }),
        new Vnode({
          tag: 'script',
          attrs: {
            type: 'application/javascript',
            nonce: nonce
          },
          children: [this.options.content || genLoaderInitScript(this.options.chunks, this.options.styles, this.options, state)]
        })
      ]
    }

    const scripts = this.matcher.getScripts(this.options.chunks)

    return scripts.map(chunk => {
      if (chunk.link) {
        return new Vnode({
          tag: 'script',
          attrs: Object.assign({
            type: 'application/javascript',
            nonce: nonce,
            src: chunk.link
          }, chunk.attrs)
        })
      }
      if (chunk.content) {
        return new Vnode({
          tag: 'script',
          attrs: Object.assign({
            type: 'application/javascript',
            nonce: nonce
          }, chunk.attrs),
          children: [chunk.content]
        })
      }
    })
  }

  getStylesContent () {
    const scriptNodes = this.getStyleNodes()
    return scriptNodes.join('')
  }

  getScriptsContent (options) {
    const scriptNodes = this.getScriptNodes(options)
    return scriptNodes.join('')
  }

  getServiceWorkerContent () {
    return getServiceWorkerScript(this.state)
  }
}

module.exports = Injector
