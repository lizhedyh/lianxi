const fs = require('fs')
const path = require('path')
const crypto = require('crypto')
const crc32 = require('./crc32')

const CWD = process.cwd()

let index = 0

function isObject (obj) {
  return typeof obj === 'object' && obj !== null
}

function SimpleWebpackSource (content) {
  return {
    source () {
      return content
    },
    size () {
      return content.length
    }
  }
}

function getFileType (str) {
  str = str.replace(/\?.*/, '')
  var split = str.split('.')
  var ext = split.pop()
  if (this.opts.transformExtensions.test(ext)) {
    ext = split.pop() + '.' + ext
  }
  return ext
}

function readFile (dest) {
  let content = ''
  try {
    content = fs.readFileSync(dest, 'utf-8')
  } catch (e) {
    console.error('Error at readFile: ', e)
  }
  return content
}

function writeFile (dest, content) {
  try {
    fs.writeFileSync(dest, content, 'utf-8')
  } catch (e) {
    console.error('Error at writeFile: ', e)
  }
}

function MD5 (content) {
  const md5 = crypto.createHash('md5')
  return md5.update(content).digest('hex')
}

function getFilenameFromIdentifier (mod) {
  let name = ''
  // resource
  if (mod && (mod.resource || mod.userRequest)) {
    name = mod.resource || mod.userRequest
  }
  if (name) return name
  // _identifier
  const identifier = mod && mod._identifier
  if (!identifier) return name
  const result = identifier.split('!').map(c => c.split(' ')) || []
  const namePos = result.length - 1
  if (!result[namePos] || !result[namePos][0]) return name
  name = result[namePos][0]
  return name
}

function ChunkNameResolver (chunk, context, usedNames, { pathNameHash, pathNameHashLength }) {
  let name = ''
  let mods = []
  // force sort modules first
  if (chunk.sortModules) {
    // for 3.x
    chunk.sortModules()
  } else {
    // for 2.x
    chunk.sortItems()
  }

  // for webpack 3.x+
  if (chunk.forEachModule) {
    mods = chunk.getModules() || []
  } else {
    // for webpack 2.x
    mods = chunk.modules
  }

  // try sort with depth
  // and get first module resource
  const mod = mods.sort((a, b) => a.depth - b.depth)[0]
  name = getFilenameFromIdentifier(mod)
  if (!name) {
    name = 'non-name-chunk-' + index++
  }

  name = name
    .replace(context, '')
    .replace(CWD, '')
    .replace(/^\//, '')
    .replace(/\/|\./g, '-')
    .toLowerCase()

  if (pathNameHash) {
    name = 'thunder-chunk-' + MD5(name).substr(0, pathNameHashLength)
  }

  if (usedNames.indexOf(name) > -1) {
    name = name + '-' + usedNames.length
  }

  usedNames.push(name)

  return name
}

function parseResourceOptions (map, type) {
  const queue = []
  if (!isObject(map)) return queue
  Object.keys(map).forEach(name => {
    const chunk = map[name]
    if (typeof chunk === 'string') {
      // default link
      queue.push({
        name,
        type: type,
        // use link or filename instead hash
        hash: MD5(chunk).slice(0, 5),
        link: chunk
      })
    } else if (isObject(chunk)) {
      queue.push({
        name,
        type: type,
        // use link or filename instead hash
        hash: chunk.hash || MD5(chunk.link || chunk.filename).slice(0, 5),
        attrs: Object.assign({}, chunk.attrs),
        link: chunk.link,
        cacheAge: chunk.cacheAge,
        filename: chunk.filename,
        runScript: chunk.runScript
      })
    }
  })
  return queue
}

function genThunderState (compilation, options) {
  const outputOptions = compilation.outputOptions
  return {
    version: options.version,
    resources: [],
    compilation: {
      hash: compilation.hash,
      fullHash: compilation.fullHash
    },
    project: options.project,
    cacheAge: options.cacheAge,
    history: options.networkTactic ? getHistory(compilation) : undefined,
    networkTactic: options.networkTactic,
    BSOptions: options.BSOptions,
    StarkOptions: options.StarkOptions,
    serviceWorker: options.serviceWorker,
    outputOptions: {
      publicPath: outputOptions.publicPath,
      crossOriginLoading: outputOptions.crossOriginLoading,
      chunkLoadTimeout: outputOptions.chunkLoadTimeout,
      fallbackCDN: options.fallbackCDN || outputOptions.publicPath,
      checksum: options.checksum,
      library: outputOptions.library,
      hotUpdateFunction: outputOptions.hotUpdateFunction,
      jsonpFunction: outputOptions.jsonpFunction
    }
  }
}

function getHistory (compilation) {
  const appDir = compilation.compiler.context
  const thunderHistoryFile = path.resolve(appDir, '.thunder-history')
  const forceUpdate = !!process.env.THUNDER_FORCE_UPDATE
  const isDev = process.env.NODE_ENV === 'development'
  const MAX_HISTORY_COUNT = 10

  let history = []

  if (fs.existsSync(thunderHistoryFile)) {
    const content = readFile(thunderHistoryFile)
    try {
      history = JSON.parse(content)
      if (!Array.isArray(history)) {
        history = []
      }
    } catch (e) {
      console.error(e)
    }
  }

  if (isDev) return history

  history.push({
    hash: compilation.hash,
    forceUpdate: forceUpdate
  })

  let cache = {}

  history = history.reduce((list, item) => {
    if (!cache[item.hash]) {
      list.push(item)
      cache[item.hash] = 1
    }
    return list
  }, [])

  while (history.length > MAX_HISTORY_COUNT) {
    history.shift()
  }

  writeFile(thunderHistoryFile, JSON.stringify(history, null, 2))

  return history
}

function oldEventNameReplace (event) {
  const matchs = event.match(/-([a-z])/g)
  let newEventName = event

  if (!matchs) return event

  matchs.forEach(mat => {
    newEventName = newEventName.replace(mat, mat.replace('-', '').toUpperCase())
  })

  return newEventName
}

function tapableAdapter (instance, event, func, type = 'tap') {
  const isWebpack4 = !!instance.hooks

  if (isWebpack4) {
    if (instance.hooks[oldEventNameReplace(event)]) {
      instance.hooks[oldEventNameReplace(event)][type]('thunder-plugin', func)
    } else {
      console.log(instance, 'does not has hook:', event, oldEventNameReplace(event))
    }
  } else {
    instance.plugin(event, func)
  }
}

const thunderStateReg = /__THUNDER_STATE__/

function getThunderSDK (type) {
  const moduleNameMap = {
    idb: path.resolve(__dirname, '../dist/thunder.idb.min.js'),
    nosw: path.resolve(__dirname, '../dist/thunder.nosw.min.js'),
    tiny: path.resolve(__dirname, '../dist/thunder.index.min.js'),
    pure: path.resolve(__dirname, '../dist/thunder.pure.min.js'),
    bootloader: path.resolve(__dirname, '../dist/thunder.bootloader.min.js')
  }

  return fs.readFileSync(moduleNameMap[type] || moduleNameMap.tiny, 'utf-8')
}

function getThunderScript (thunderState, type) {
  try {
    const content = getThunderSDK(type)
    let client = `
    ;(function (global) {
      ${content}
      var thunderStateString = '__THUNDER_STATE__'
      var thunderState = global.__thunderState__
      
      try {
        thunderState = thunderState || JSON.parse(atob(thunderStateString))
        global.__thunder__ = new Thunder(thunderState)
      } catch (e) {
        console.error('ERROR at init Thunder: ');
        console.error(e);
      }
    })(window)`

    client = client.replace(thunderStateReg, Buffer.from(JSON.stringify(thunderState)).toString('base64'))

    return client
  } catch (e) {
    console.error('failed at generate thunder client', e)
    throw e
  }
}

const THUNDER_HASH_REG = /\[thunder-sw-hash\]/
const THUNDER_SCOPE_REG = /\[thunder-sw-scope\]/
const THUNDER_SW_OPTIONS_REG = /__THUNDER_STATE__SW__/

function getServiceWorkerScript (thunderState) {
  let content = ''
  try {
    content = fs.readFileSync(path.resolve(__dirname, '../dist/service-worker.js'), 'utf-8')
    content = content.replace(THUNDER_HASH_REG, thunderState.compilation.hash)
    if (thunderState.serviceWorker) {
      content = content.replace(THUNDER_SW_OPTIONS_REG, Buffer.from(JSON.stringify(thunderState)).toString('base64'))
      content = content.replace(THUNDER_SCOPE_REG, thunderState.serviceWorker.scope)
    }
    return content
  } catch (e) {
    console.error('failed at thunder read service-worker', e)
  }
}

function getFileByType (reg, files) {
  return files.filter(reg.test.bind(reg))
}

// for webpack 4+
function mapChunkGroups (compilation) {
  let chunks = []
  const resources = []

  compilation.chunkGroups.forEach(group => {
    chunks = chunks.concat(group.chunks)
  })

  chunks.map(chunk => {
    return {
      name: chunk.id || '',
      js: getFileByType(/\.js$/i, chunk.files),
      css: getFileByType(/\.css$/i, chunk.files)
    }
  })
    .filter(chunk => chunk.name)
    .forEach(chunk => {
      if (chunk.css.length) {
        chunk.css.map(file => {
          resources.push({
            name: chunk.name,
            type: 'css',
            filename: file
          })
        })
      }
      if (chunk.js.length) {
        chunk.js.map(file => {
          resources.push({
            name: chunk.name,
            type: 'js',
            filename: file
          })
        })
      }
    })

  return resources
}

// for webpack v3 v2
// resources file
function mapChunksFile (compilation) {
  const resources = []

  compilation.chunks.map(chunk => {
    return {
      name: chunk.id || '',
      js: getFileByType(/\.js$/i, chunk.files),
      css: getFileByType(/\.css$/i, chunk.files)
    }
  })
    .filter(chunk => chunk.name)
    .forEach(chunk => {
      if (chunk.css.length) {
        chunk.css.map(file => {
          resources.push({
            name: chunk.name,
            type: 'css',
            filename: file
          })
        })
      }
      if (chunk.js.length) {
        chunk.js.map(file => {
          resources.push({
            name: chunk.name,
            type: 'js',
            filename: file
          })
        })
      }
    })

  return resources
}

function genResourceMap (compilation, options, state) {
  let resourceQueue = []

  // for webpack v4
  if (compilation.chunkGroups) {
    resourceQueue = mapChunkGroups(compilation)
  } else {
    // for webpack v3
    resourceQueue = mapChunksFile(compilation)
  }

  resourceQueue.map(re => {
    if (re.filename && compilation.assets[re.filename]) {
      re.checksum = crc32(compilation.assets[re.filename].source())
    }
  })

  const jsQueue = parseResourceOptions(options.resources.js, 'js')
  const cssQueue = parseResourceOptions(options.resources.css, 'css')

  resourceQueue = resourceQueue.concat(jsQueue, cssQueue)

  const resMarkMap = {}

  // type + name should be unique
  resourceQueue = resourceQueue.filter(res => {
    if (resMarkMap[res.type + res.name]) return false
    resMarkMap[res.type + res.name] = true
    return true
  })

  return resourceQueue
}

function genSourceMapSalt (compiler) {
  let sourceMapSalt = ''

  if (compiler.options.devtool) {
    sourceMapSalt += compiler.options.devtool
  }

  compiler.options.plugins.forEach(plugin => {
    const pluginName = plugin.constructor.name
    if (pluginName === 'SourceMapDevToolPlugin' || pluginName === 'EvalSourceMapDevToolPlugin') {
      sourceMapSalt += JSON.stringify(plugin)
    }
  })

  if (!sourceMapSalt) {
    return sourceMapSalt
  }
  return MD5(sourceMapSalt)
}

module.exports = {
  getThunderScript,
  getThunderSDK,
  getServiceWorkerScript,
  tapableAdapter,
  ChunkNameResolver,
  getFilenameFromIdentifier,
  MD5,
  readFile,
  writeFile,
  getFileType,
  genThunderState,
  SimpleWebpackSource,
  getHistory,
  genResourceMap,
  genSourceMapSalt
}
