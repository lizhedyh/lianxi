const Emitter = require('events')
const assert = require('assert')
const htmlWebpackPluginHelper = require('./html-webpack-plugin-helper')
const templateInjector = require('./injector')
const MODULE_TYPE = 'css/mini-extract' // mini-css-extract-plugin

const { version } = require('../package.json')

const {
  ChunkNameResolver,
  genThunderState,
  SimpleWebpackSource,
  tapableAdapter,
  getThunderSDK,
  getServiceWorkerScript,
  genResourceMap,
  genSourceMapSalt
} = require('./util')
const crc32 = require('./crc32')
const {
  LOADER_SCRIPT,
  LOADER_SCRIPT_STYLE
} = require('./template')

const defaultOutput = {
  state: 'thunder-state.json',
  thunder: 'thunder.[hash].js', // [hash]
  serviceWorker: 'service-worker.js'
}

class ThunderPlugin extends Emitter {
  constructor (props = {}) {
    super()
    const resources = props.resources || {}
    this.options = {
      version: 2,
      output: Object.assign({}, {
        state: defaultOutput.state,
        thunder: false, // [hash]
        serviceWorker: false
      }, props.output),
      resources: {
        css: resources.css || {},
        js: resources.js || {}
      },
      cacheAge: props.cacheAge || 0,
      pathNameHash: props.pathNameHash || false,
      pathNameHashLength: props.pathNameHashLength || 16,
      StarkOptions: props.StarkOptions,
      project: props.project,
      bootloaderMode: props.bootloaderMode || 'tiny',
      serviceWorker: props.serviceWorker,
      fallbackCDN: props.fallbackCDN,
      checksum: typeof props.checksum === 'boolean' ? props.checksum : true,
      outputOptions: {},
      hookHtmlWebpackPlugin: props.hookHtmlWebpackPlugin,
      injectHTML: props.injectHTML
    }

    assert(props.project, '请在插件配置项中添加 project 配置，如：project: "era-web"，不能和其他项目重复，用于隔离多个项目共用域名时的缓存隔离')

    this.thunderState = {
      version: 2,
      chunksMap: {},
      stylesMap: {},
      compilation: {
        hash: '',
        fullHash: ''
      },
      cacheAge: this.options.cacheAge,
      // BSOptions: this.options.BSOptions,
      StarkOptions: this.options.StarkOptions,
      serviceWorker: this.options.serviceWorker,
      outputOptions: {},
      resources: {}
    }

    this.state = {
      thunderClient: '',
      serviceWorker: ''
    }

    if (this.options.hookHtmlWebpackPlugin) {
      htmlWebpackPluginHelper(this.options.hookHtmlWebpackPlugin, this)
    }
  }

  get sdkFilename () {
    if (!this.options.output.thunder) return ''
    const thunderFilename = this.options.output.thunder
      .replace('[hash]', this.thunderState.compilation.hash)
    return thunderFilename
  }

  updateState (compilation, callback) {
    // 在输出 thunder state 前注入 resources\
    const thunderType = this.options.bootloaderMode
    this.state.thunderClient = getThunderSDK(thunderType)
    this.thunderState.resources = genResourceMap(compilation, this.options, this.thunderState)
    this.thunderState.outputOptions.thunder = {
      filename: `thunder-${thunderType}-${version}.js`,
      attrs: {},
      checksum: crc32(this.state.thunderClient)
    }
    this.emit('update', this.thunderState)

    // thunder.js
    compilation.assets[this.thunderState.outputOptions.thunder.filename] = SimpleWebpackSource(this.state.thunderClient)

    // service-worker.js
    if (this.thunderState.serviceWorker && this.options.output.serviceWorker) {
      compilation.assets[this.options.output.serviceWorker] = SimpleWebpackSource(getServiceWorkerScript(this.thunderState))
    }

    // thunder-state.json
    if (this.options.output.state) {
      const fileContent = JSON.stringify(this.thunderState, null, 2)
      compilation.assets[this.options.output.state] = SimpleWebpackSource(fileContent)
    }

    // injectHTML
    if (this.options.injectHTML) {
      // templateInjector 是一个异步操作
      // 为确保测试，在 injector 完成之后调用 callback
      templateInjector(this.options.injectHTML, compilation, this.thunderState)
        .then(() => callback())
        .catch(callback)
    } else {
      callback()
    }
  }

  apply (compiler) {
    const self = this
    this.options.outputOptions = Object.assign(this.options.outputOptions, compiler.options.output)
    /*
    * reset chunk id to it's relative path
    */
    tapableAdapter(compiler, 'compilation', compilation => {
      tapableAdapter(compilation, 'before-chunk-ids', (chunks) => {
        const usedNames = []
        chunks.forEach((chunk) => {
          if (chunk.name) {
            chunk.id = chunk.name
          } else if (chunk.id == null) {
            chunk.id = ChunkNameResolver(chunk, compilation.options.context, usedNames, this.options)
          }
        })
      })
    })

    /*
    * generate chunk map data
    */
    tapableAdapter(compiler, 'compilation', compilation => {
      tapableAdapter(compilation, 'additional-chunk-assets', (chunks) => {
        self.thunderState = genThunderState(compilation, self.options)
        self.emit('update', self.thunderState)
      })
    })

    /*
    * generate chunks map.json
    */
    // additional-assets 会多次调用
    // compilation.hash 会多次更新

    tapableAdapter(compiler, 'emit', (compilation, callback) => {
      this.updateState(compilation, callback)
    }, 'tapAsync')

    tapableAdapter(compiler, 'compilation', (compilation) => {
      tapableAdapter(compilation, 'after-seal', (callback) => {
        this.updateState(compilation, callback)
      }, 'tapAsync')
    })

    /*
    * hook jsonp-script loader
    */
    tapableAdapter(compiler, 'compilation', compilation => {
      const isWebpack4 = !!compilation.hooks
      const { mainTemplate } = compilation

      if (isWebpack4) {
        const Template = require('webpack/lib/Template')
        if (!mainTemplate.hooks.jsonpScript) return

        mainTemplate.hooks.jsonpScript.tap('thunder-jsonp-script', (source, chunk, hash) => {
          return Template.asString([LOADER_SCRIPT_STYLE, source])
        })

        // mini-css-extract-plugin style loader hook
        process.nextTick(() => {
          mainTemplate.hooks.requireEnsure.taps.forEach((plugin, i) => {
            if (plugin.name !== 'mini-css-extract-plugin') return
            const fn = mainTemplate.hooks.requireEnsure.taps[i].fn
            const thunderWrapper = function (...args) {
              const result = fn.apply(this, args)
              return `
              if ('__thunder__' in window && window.__thunder__ && window.__thunder__.running) {
                // thunder is running, skip mini css loader
              } else {
                // thunder is not running, use mini css loader
                ${result}
              }
              `
            }
            mainTemplate.hooks.requireEnsure.taps[i].fn = thunderWrapper
          })
        })
      } else {
        mainTemplate.plugin('jsonp-script', function (source, chunk, hash) {
          return this.asString([LOADER_SCRIPT, source])
        })
      }
    })

    /*
    * add sourcemap config to hashSalt
    */
    tapableAdapter(compiler, 'compilation', compilation => {
      const sourceMapSalt = genSourceMapSalt(compiler, compilation)
      if (!sourceMapSalt) {
        return
      }

      tapableAdapter(compilation, 'before-hash', () => {
        const outputHashSalt = compiler.options.output.hashSalt ? compiler.options.output.hashSalt : ''

        compiler.options.output.hashSalt = outputHashSalt + sourceMapSalt
      })
    })

    /*
    * add sourcemap config as comment to CSS module
    * webpack4 use mini-css-extract-plugin to extract CSS
    * webpack3 use extract-text-webpack-plugin to extract CSS
    */
    tapableAdapter(compiler, 'compilation', compilation => {
      const isWebpack4 = !!compilation.hooks
      const sourceMapSalt = genSourceMapSalt(compiler, compilation)

      if (!sourceMapSalt) {
        return
      }

      if (isWebpack4) {
        tapableAdapter(compilation, 'finish-modules', modules => {
          modules.forEach((module) => {
            if (module.type === MODULE_TYPE) {
              module.content = module.content + `.thunder-sourcemap-comment{/*! ${sourceMapSalt} */}`
            }
          })
        })
      } else {
        // hook optimize-extracted-chunks will be called in extract-text-webpack-plugin
        tapableAdapter(compilation, 'optimize-extracted-chunks', (extractedChunks) => {
          extractedChunks.forEach((extractedChunk) => {
            extractedChunk.forEachModule((module) => {
              module._source = module._source + `\n.thunder-sourcemap-comment {\n  /*! ${sourceMapSalt} */\n}`
            })
          })
        })
      }
    })
  }
}

module.exports = ThunderPlugin
